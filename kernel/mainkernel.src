import_code("../libs/utils")
import_code("../libs/sessionmanager")
import_code("../libs/proxyextension")
import_code("../libs/argparse")
import_code("../constants/settings")
import_code("./overrides")

Kernel = {}
Kernel.DEBUG = false
Kernel.nightly = false
Kernel.version = "2.19.3"
Kernel.keep_session = true

Kernel.sessions = []
Kernel.session_count = 1
Kernel.session = null
Kernel.active_sessions = []
Kernel.active_session = null
Kernel.env = {}
Kernel.env.ACTIVE = 1
Kernel.env.CURRENT = 1

Kernel.tools = {}
Kernel.commands = {}
Kernel.raw_settings = null
Kernel.settings = {}
Kernel.old_stdout = []
Kernel.stdout = []
Kernel.last_error = null
Kernel.raw_piped = false
Kernel.piped = false
Kernel.quit_pipe = false
Kernel.silent = false


Kernel.new_session = function(session)
    session.id = self.session_count
    self.session_count = self.session_count + 1
    self.sessions.push(session)
end function


Kernel.use_session = function(session)
    self.session = session

    self.env.CURRENT = session.id
    self.env.HOME = function(); return session.homepath; end function
    self.env.PWD = function(); return session.file.path; end function
    self.env.WAN = function(); return session.wan; end function
    self.env.LAN = function(); return session.lan; end function

    self.env.USER = function(); return session.user; end function
    self.env.COMP = function(); return session.comp_name; end function

    if session.computer != null then
        self.env.WAN = function(); pub_ip = "unknown"; if not session.computer then return pub_ip; result = session.computer.public_ip; if not is_error(result) then pub_ip = result; return pub_ip; end function
        self.env.LAN = function(); loc_ip = "unknown"; if not session.computer then return loc_ip; result = session.computer.local_ip; if not is_error(result) then loc_ip = result; return loc_ip; end function
    end if
    
    status = "Jumped"
    if session == self.active_session then
        status = "Active"
    else if self.active_sessions.indexOf(session) != null then
        status = "Parses"
    end if
    
    self.env.STATUS = status
    
    suffix = self.settings.input.file
    ses_type = "File"
    if session.hasIndex("partial_interpreter") and session.partial_interpreter != null then
        suffix = self.settings.input.zday
        ses_type = "Partial"
    else if session.shell != null then
        suffix = self.settings.input.shell
        ses_type = "Shell"
    else if session.computer != null then
        suffix = self.settings.input.computer
        ses_type = "Computer"
    end if

    self.env.SESTYPE = ses_type
    self.env.SUFFIX  = suffix
    self.env.EFFECTIVE = "Unknown"

    if session.hasIndex("effective") then
        self.env.EFFECTIVE = session.effective
    end if
end function


Kernel.get_session = function(session_id)
    for x in self.sessions
        if x.id == session_id then
            return x
        end if
    end for
end function


Kernel.parse_command = function(text)
    commands = []
    pipes = [[]]
    
    quote = null
    last = null
    backs = 0

    // Parse input, and keep quotes
    parsed = parse_input(text, false, true)

    for x in parsed
        if x.trim == "&&" then
            pipes[-1] = pipes[-1].join(" ")
            commands.push(pipes)
            pipes = [[]]

        else if x.trim == "|" then
            pipes[-1] = pipes[-1].join(" ")
            pipes.push([])
        else
            pipes[-1].push(x)
        end if
    end for

    pipes[-1] = pipes[-1].join(" ")

    if pipes[-1] == "" then
        pipes.pop()
    end if

    if pipes == [] then return null

    if pipes[0] != "" or pipes.len > 1 then commands.push(pipes)
    
    has_history = false
    for command in commands
        for pipe in command
            val = pipe.trim
            temp = val.split(" ")
            
            // Env variable parsing
            for t in temp
                if t[-1] == "'" or t[-1] == """" then ending = t[-1] else ending = ""
                t = t.replace("'", "").replace("""", "")
                if t.is_match("^\$\w+$") then
                    env_val = t[1:]
                    if not self.env.hasIndex(env_val) then continue
                    result = @self.env[env_val]
                    if typeof(@result) == "function" then
                        temp[__t_idx] = result() + ending
                    else if @result isa string and EvalType.New(result).type == "string" then
                        temp[__t_idx] = "'"+self.env[env_val].replace("'", "\'") + "'"
                    else
                        temp[__t_idx] = self.env[env_val] + ending
                    end if
                    continue
                end if
                if t.len >= 2 and t[0] == "\" and t[1] == "$" then temp[__t_idx] = t[1:] + ending
            end for
            val = temp.join(" ")
            commands[__command_idx][__pipe_idx] = val
            cmd = val.split(" ")[0]

            // Check for history
            if val.is_match("^\^\d*.*$") then
                if self.session.history.len == 0 then continue

                parts = val.matches("^\^\d*(?=(\s|$))")
                if parts == {} then continue
                part = parts[0]

                if part == "^" then
                    commands[__command_idx][__pipe_idx] = val.replace("\^", self.session.history[-1])
                    has_history = true
                    continue
                end if

                history_index = part[1:].to_int
                if self.session.history.len <= history_index then continue
                has_history = true
                commands[__command_idx][__pipe_idx] = val.replace("\"+part, self.session.history[-(history_index+1)])
            
            // Check for aliases
            else if self.settings.hasIndex("alias") and self.settings.alias.hasIndex(cmd) then
                commands[__command_idx][__pipe_idx] = self.settings.alias[cmd] + " " + val.split(" ")[1:].join(" ")
                has_history = true
            end if
        end for
    end for

    joined = []
    for cmd in commands 
        joined.push(cmd.join(" | "))
    end for
    joined = joined.join(" && ")

    result = {}
    result.parsed = commands
    result.string = joined

    if has_history then return self.parse_command(joined)

    return result
end function


Kernel.run_command = function(text, add_to_history=true, silent=false)
    commands = self.parse_command(text)
    if commands == null then return false

    if (self.session.history.len > 0 and self.session.history[-1] != commands.string) or self.session.history.len == 0 then
        if add_to_history then
            self.session.history.push(commands.string)
        end if
    end if

    prev_silent = self.silent
    self.silent = silent
    good_result = true

    if self.DEBUG then
        e = []
        print(commands.string)
        print(commands.parsed)
    end if

    for command in commands.parsed
        self.piped = command.len > 1
        self.old_stdout = self.stdout.values
        self.stdout = []
        self.last_error = null
        self.quit_pipe = false
        had_success = false
        redirected = false
        redirctbuff = ""
        fullRedirect = false
        redirectFile = null

        for pipe in command
            if self.quit_pipe then break
            parts = parse_input(pipe, true)
            if self.DEBUG then print(pipe)

            if len(parts) == 0 then continue

            cmd = parts[0].value
            cmd_obj = null

            // DEBUG STUFF
            if self.DEBUG then
                e = []
                for p in parts
                    e.push(p.eval_value)
                end for
                print(e)
            end if

            if self.commands.hasIndex(cmd) then
                cmd_obj = self.commands[cmd]

            else if self.tools.hasIndex(cmd) then
                cmd_obj = self.tools[cmd]

            else
                print("Command not found: " + cmd)
                good_result = false
                break
            end if
            
            /////////// START MAIN REDIRECTION LOGIC ///////////

            if parts.len > 2 and (parts[-2].value == ">>" or parts[-2].value == ">") then
                path = parts[-1].eval_value
                if path != "" then 
                    if parts[-2].value == ">" then fullRedirect = true
                    redirected = true
                    session_file = self.session.file
                    temp = session_file.get_file(path)

                    if not is_error(temp) and temp.is_binary then
                        had_success = false
                        self.last_error = OsError.New("stdout.redirect", "Invalid target: Binary")
                        break
                    end if
        
                    if path[0] != "/" then path = session_file.path + "/" + path
                    comp = self.session.computer

                    redirectFile = temp
                    if comp and is_error(temp) then 
                        temp = comp.touch(parent_path(path),path.split("/")[-1])
                        redirectFile = session_file.get_file(path)
                    end if

                    if is_error(temp) or is_error(redirectFile) then
                        had_success = false
                        if is_error(temp) then self.last_error = temp else self.last_error = redirectFile
                        break
                    end if

                    if not fullRedirect then
                        if not redirectFile.has_permission("r") or not redirectFile.parent.has_permission("w") then
                            redirected = false
                            self.last_error = PermissionError.New("stdout.redirect","read & write")
                            continue
                        end if
                    else 
                        if not redirectFile.parent.has_permission("w") then
                            redirected = false
                            fullRedirect = false
                            self.last_error = PermissionError.New("stdout.redirect","write")
                            continue
                        end if
                    end if
                end if
                for x in range(0,1)
                    parts.pop()
                end for
            end if
            
            /////////// END MAIN REDIRECTION LOGIC ///////////

            if __pipe_idx == 0 then
                prev_piped_status = self.piped
                if redirected then self.piped = true
                
                result = cmd_obj.call(self, parts[1:])
                if result == false then
                    had_success = false
                else if not is_error(result) then 
                    had_success = true
                else
                    self.last_error = result.stack("Kernel.run_command")
                end if

                if redirected then 
                    self.piped = prev_piped_status
                    prev = ""
                    if not fullRedirect then 
                        cont = redirectFile.get_content
                        if cont.len == 0 then prev = cont else prev = cont + char(10)
                        remove(locals, "cont")
                    end if
                    redirectFile.set_content(prev + unformat_string(self.stdout.join(char(10))))
                    redirected = false
                    fullRedirect = false
                    self.old_stdout = self.stdout.values
                    self.stdout = [""]
                    self.raw_piped = true
                end if

                if result isa string then
                    self.print(result)
                end if
            else
                was_piped = self.piped
                if __pipe_idx == command.len - 1 then self.piped = false
                prev_piped_status = self.piped
                self.old_stdout = self.stdout.values
                self.stdout = []
                for x in self.old_stdout
                    parts_2 = parse_input(unformat_string(trim(x)), true)

                    result = cmd_obj.call(self, parts[1:] + parts_2)
                    if redirected then
                        if typeof(self.old_stdout) == "list" then redirctbuff = redirctbuff + self.old_stdout.join(char(10))
                    end if
                    if not is_error(result) then 
                        had_success = true
                    else
                        self.last_error = result.stack("Kernel.run_command")
                        print(self.last_error.trace())
                    end if
                end for
                if redirected then
                    self.piped = prev_piped_status
                    prev = ""
                    if not fullRedirect then 
                        cont = redirectFile.get_content
                        if cont.len != 0 then prev = cont + char(10)
                        remove(locals, "cont")
                    end if
                    redirectFile.set_content(prev + unformat_string(redirctbuff))
                    redirected = false
                    fullRedirect = false
                end if
            end if

            if not self.raw_piped then
                for x in self.stdout
                    self.stdout[__x_idx] = """" + x.replace("""", """""") + """"
                end for
            end if
            self.raw_piped = false
        end for

        if not had_success then
            good_result = false
        end if
        if not had_success and self.last_error != null and not silent then
            if self.DEBUG then
                print(self.last_error.trace)
            else
                print(self.last_error.message)
            end if
            break
        end if
    end for

    self.silent = prev_silent
    return good_result
end function


Kernel.load_tools = function(full_reset=false)
    custom_obj = get_custom_object
    if full_reset then
        self.tools = {}
        self.commands = {}
    end if

    shell = self.sessions[0].shell
    comp = shell.host_computer
    folders = comp.File("/etc/crow/tools")
    if folders isa Error then exit(folders.stack("Kernel.load_tools").trace)

    for x in folders.get_files
        self.print("$P;Loading $T2;<b>" + x.name)

        custom_obj.result = []
        shell.launch(x.path, "init")
        if custom_obj.result == [] then
            print("    <#f00>Failed to import tool")
            continue
        end if

        result = get_custom_object.result
        for tool in result
            tool._kernel = self
            self.tools[tool.name] = tool

            if hasIndex(tool, "settings") and tool.settings != null then
                save = false
                for category in tool.settings.data
                    cat = category.key
                    if not hasIndex(self.settings, cat) then
                        self.settings[cat] = {}
                    end if
                    for setting in category.value
                        if not hasIndex(self.settings[cat], setting.key) then
                            self.settings[cat][setting.key] = setting.value
                            self.raw_settings = self.raw_settings + char(10) + cat + " " + setting.key + " = " + setting.value
                            save = true
                        end if
                    end for
                end for
                if save then self.save_settings()
            end if

            for command in tool.commands
                if not command.value.standalone then continue
                self.commands[command.key] = command.value
            end for

            if tool.hasIndex("on_load") then
                result = tool.on_load(self)
                if is_error(result) then
                    self.print("    "+OsError.New(tool.name+".on_load", result.message).trace)
                end if
            end if

            self.print("    "+ "$T;Loaded $T2;" + "$T2;(" + tool.version + ")<b> $S;" + tool.name + " $T2;" + tool.loaded_commands + " $T;/$T2; " + tool.total_commands)
 
        end for
        remove(custom_obj, "result")
    end for
    print(" ")
    self.print("$P;Loaded a total of $S;<b>" + self.tools.len + " </b>$P;tools.")
end function


Kernel.load_settings = function(path="/etc/crow/data/settings.txt")
    shell = self.sessions[0].shell
    comp = shell.host_computer
    file = shell.File(path)
    settings = {}

    if is_error(file) then
        if path == "/etc/crow/data/settings.txt" then
            print("Saving default settings to " + path)
            result = comp.touch("/etc/crow/data", "settings.txt", SETTINGS_DEFAULT)
            if result isa Error then return result.stack("Kernel.load_settings")

            error = self.load_settings(path)
            return error
        else
            return file
        end if
    end if

    raw_settings = file.get_content
    if is_error(raw_settings) then return raw_settings.stack("Kernel.load_settings")

    settings = raw_settings.split(char(10))
    out = {}
    for i in range(0, settings.len-1)
        line = settings[i].trim

        if line == "" then continue
        if line[:2] == "//" then continue

        data = line.split("=")
        if data.len < 2 then
            print(Error.New("(Settings)", "Invalid format: '"+line+"' on line "+i+". Skipping").message)
            continue
        end if
        
        setting_vars = data[0].trim.split(" ")
        if setting_vars.len != 2 then
            print(Error.New("(Settings)", "Invalid assignment : '"+line+"' on line "+i+". Skipping").message)
            continue
        end if

        category = setting_vars[0]
        key = setting_vars[1]
        value = data[1:].join("=").trim

        if out.indexes.indexOf(category) == null then out[category] = {}

        out[category][key] = value
    end for

    self.raw_settings = raw_settings
    self.settings = out

    // Check if old propmt exists, if so, overwrite it
    __override_prompts(self)
end function


Kernel.save_settings = function()
    user_settings = self.sessions[0].homepath
    
    f = self.sessions[0].file.get_file(user_settings+"/.crowrc")
    if is_error(f) then return f.stack("Kernel.save_settings")

    f.set_content(self.raw_settings)
end function


Kernel.get_prompt = function()
    temp_env = {}
    for x in self.env
        key = x.key
        val = x.value

        if key == "USER" then
            temp_env[key] = val
            if val == "root" then temp_env[key] = "$root;root"

        else if key == "STATUS" then
            temp_env[key] = "$status_" + lower(val) +";" + val
            
        else if key == "EFFECTIVE" then
            temp_env[key] = "$none;None"
            if val == "guest" then
                temp_env[key] = "$guest;Guest"
            else if val == "root" then
                temp_env[key] = "$root;Root"
            else if val == "none" then
                temp_env[key] = "$none;None"
            else
                temp_env[key] = "$user;User"
            end if
        else
            temp_env[key] = val
        end if
    end for
    
    if self.sessions[0] == self.session then
        if self.settings.hasIndex("interface") and self.settings.interface.streamer_mode == "true" then
            temp_env["WAN"] = "[CENSORED]"
        end if
    end if

    raw_prompt = self.settings.input.prompt
    if self.session.hasIndex("partial_interpreter") and self.session.partial_interpreter != null then
        pi = self.session.partial_interpreter
        raw_prompt = self.settings.zday.prompt
        color = "$zday;"
        if pi.metalib != null then
            color = ["$bad;","$good;"][pi.metalib.is_patched]
        end if
        raw_prompt = raw_prompt.replace("\$PWD", color + self.session.file.path)
    end if

    for x in temp_env
        raw_prompt = raw_prompt.replace("\$"+x.key, ""+x.value)
    end for
    // raw_prompt = raw_prompt.replace("\$usr", user)
    // raw_prompt = raw_prompt.replace("\$comp", self.session.comp_name)
    // raw_prompt = raw_prompt.replace("\$pwd", self.session.file.path)
    // raw_prompt = raw_prompt.replace("\$type", type)
    // raw_prompt = raw_prompt.replace("\$status", status)
    // raw_prompt = raw_prompt.replace("\$suffix", suffix)
    // raw_prompt = raw_prompt.replace("\$session", self.settings.color.session + self.session.id)
    // raw_prompt = raw_prompt.replace("\$ip", self.settings.color.ip_prompt + ip)
    // raw_prompt.replace("\$pwd", self.active_session.file.path)
    return self.color(raw_prompt)
end function


// Kernel API functions for tools
Kernel.color = function(object)
    if not object isa list then
        object = "" + object
    end if
    if not object isa string and not object isa list then return TypeError.New("kernel_color", "string | list[string]", typeof(object))
    
    if object isa list then
        result = []
        for text in object
            new_text = self.color(text)
            if new_text isa Error then return new_text.stack("Kernel.color")
            result.push(new_text)
        end for
        return result
    else
        result = object
        if not self.settings.hasIndex("color") then return Error.New("kernel_color", "Color not found in settings")

        for color in self.settings["color"]
            result = result.replace("\$"+color.key+";", color.value)
        end for
        return result
    end if
end function


Kernel.print = function(msg, clear)
    raw_msg = msg
    if self.settings.hasIndex("interface") and self.settings.interface.streamer_mode == "true" then
        msg = str(msg).replace(self.sessions[0].wan, "[CENSORED]")
    end if
    
    seperated = self.color(str(raw_msg)).split(char(10))
    self.stdout = self.stdout + seperated
    if not self.piped and not self.silent then print(self.color(msg), clear)
end function


Kernel.line = function(title, length)
    sep = floor((length - title.len - 4)/2)
    if title == "" then 
        self.print("$T;" + "—"*length)
    else
        self.print(("$T;" + "—"*sep + "(<b>$T2; " + title + "</b> $T;)" + "—"*sep))
    end if
end function


Kernel.check_update = function(interface_version)
    ver_string = []
    for x in self.tools.values
        ver_string.push(x.name + "@" + x.version)
    end for

    ver_string.push("kernel@" + self.version)
    if interface_version then ver_string.push("interface@"+interface_version)

    pad = function(num, to)
        temp = ""+num
        return "0"*(to-len(temp))+temp
    end function
    
    unix_time = function()
        _month = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]
        dt = current_date().split(" ")
        dates = dt[0].split("/"); times = dt[2].split(":")
        d = dates[0].to_int(); m = _month.indexOf(dates[1]) + 1; y = dates[2].to_int()
        y = y - (m <= 2)
        era = y; if y < 0 then era = y - 399; era = floor(era / 400)
        yoe = floor(y - era * 400)
        if m > 2 then t = m - 3 else t = m + 9
        doy = floor((153 * t + 2) / 5 + d - 1)
        doe = floor(yoe * 365 + yoe / 4 - yoe / 100 + doy)
        epoch_days = era * 146097 + doe - 719468 + 1
        
        result = (epoch_days * 24 + times[0].to_int()) * 3600 + times[1].to_int() * 60
        return result
    end function

    password = "4yvfEJrhy3W1337" + pad(unix_time, 11)

    print(" ")
    self.print("$P;Checking for updates...")
    self.print("$P;Connecting to crowsploit servers $T;(versioncheck@159.139.90.130:69)")
    if not self.sessions[0].computer.is_network_active then return kernel.print("$error;Unable to connect; no internet connection")
    result = self.sessions[0].shell.connect_service("159.139.90.130", 69, "versioncheck", password, "ftp")
    if is_error(result) then return result.stack("kernel.check_update")

    result.launch("/home/versioncheck/check",ver_string.join(" "))
end function

// Environment functions

Kernel.env.RAND_IP = function()
    ip = random(1,224)+"."+random(0,255)+"."+random(0,255)+"."+random(0,255)
    while not is_valid_ip_range(ip)
        ip = random(1,224)+"."+random(0,255)+"."+random(0,255)+"."+random(0,255)
    end while
    return ip
end function