import_code("../libs/utils")
import_code("../libs/sessionmanager")
import_code("../libs/proxyextension")
import_code("../libs/argparse")

SETTINGS_DEFAULT = "// Format:
// [category] [key] = [value]

// Categories and keys cannot have spaces

////////////////
//// Colors ////

// primary color
color P = <#08f>

// secondary color
color S = <#0cc>

// tertiary colors
color T = <#669>
color T2 = <#99c>

// Input color
color input = <#bcf>

// Root color
color root = <#f60>

// Error color
color error = <#e05>

//// LS data
color lsfolder = <#08f>
color lsbinary = <#0e8>
color lsfile   = <#aad>
color lsdata   = <#99c>
color lsuser   = <#99c>
color lscode   = <#fc1>
color lssymlink = <#c158d6>

// Argument colors
color string = <#d63>
color int    = <#39d>
color float  = <#b5e>
color bool   = <#35f>
color ip     = <#d44>
color rest   = <#557>

// Status colors
color status_active = <#c80>
color status_jumped = <#7c7>
color status_parses = <#c4c>
color status_none   = <#669>
color session       = <#669>
color ip_prompt     = <#d44>

/////////////////
// User prompt //
input prompt = <voffset=2em> </voffset><pos=0><size=85%><voffset=1.4em>$S;$type $status $session $ip</voffset><pos=0></size>$T;($pwd) $P;$usr$T;@$S;$comp $T2;$suffix$input;

///////////////////
// Input sufixes //
// example: (pwd) user@pc > 
// example: (pwd) user@pc : 
// example: (pwd) user@pc - 

input shell    = >
input computer = :
input file     = -

//////////////
// Database //

database location = /etc/crow/exdb


///////////////////////
// Library directory //

library path = /etc/crow/libs
library auto_update_meta = true
library auto_install = true


////////////////////
// Update checker //

update check = true

/////////////
// Aliases //
alias c = clear
alias la = ls -la
alias sessions = session list"

Kernel = {}
Kernel.DEBUG = false
Kernel.nightly = false
Kernel.version = "2.18.0"
Kernel.keep_session = true

Kernel.sessions = []
Kernel.session_count = 1
Kernel.session = null
Kernel.active_sessions = []
Kernel.active_session = null
Kernel.env = {}
Kernel.env.ACTIVE = 1
Kernel.env.CURRENT = 1

Kernel.tools = {}
Kernel.commands = {}
Kernel.raw_settings = null
Kernel.settings = {}
Kernel.old_stdout = []
Kernel.stdout = []
Kernel.last_error = null
Kernel.raw_piped = false
Kernel.piped = false
Kernel.quit_pipe = false
Kernel.silent = false


Kernel.new_session = function(session)
    session.id = self.session_count
    self.session_count = self.session_count + 1
    self.sessions.push(session)
end function


Kernel.use_session = function(session)
    self.session = session

    self.env.CURRENT = session.id
    self.env.HOME = function(); return session.homepath; end function
    self.env.PWD = function(); return session.file.path; end function
    self.env.WAN = function(); return session.wan; end function
    self.env.LAN = function(); return session.lan; end function

    self.env.USER = function(); return session.user; end function
    self.env.COMP = function(); return session.comp_name; end function

    if session.computer != null then
        self.env.WAN = function(); return session.computer.public_ip; end function
        self.env.LAN = function(); return session.computer.local_ip; end function
    end if
end function


Kernel.get_session = function(session_id)
    for x in self.sessions
        if x.id == session_id then
            return x
        end if
    end for
end function


Kernel.parse_command = function(text)
    commands = []
    pipes = [[]]
    
    quote = null
    last = null
    backs = 0

    // Parse input, and keep quotes
    parsed = parse_input(text, false, true)

    for x in parsed
        if x.trim == "&&" then
            pipes[-1] = pipes[-1].join(" ")
            commands.push(pipes)
            pipes = [[]]

        else if x.trim == "|" then
            pipes[-1] = pipes[-1].join(" ")
            pipes.push([])
        else
            pipes[-1].push(x)
        end if
    end for

    pipes[-1] = pipes[-1].join(" ")

    if pipes[-1] == "" then
        pipes.pop()
    end if

    if pipes[0] != "" or pipes.len > 1 then commands.push(pipes)
    
    has_history = false
    for command in commands
        for pipe in command
            val = pipe.trim
            temp = val.split(" ")
            
            // Env variable parsing
            for t in temp
                if t.is_match("^\$\w+$") then
                    env_val = t[1:]
                    if not self.env.hasIndex(env_val) then continue
                    result = @self.env[env_val]

                    if typeof(@result) == "function" then
                        temp[__t_idx] = result()
                    else if @result isa string and EvalType.New(result).type == "string" then
                        temp[__t_idx] = "'"+self.env[env_val].replace("'", "\'") + "'"
                    else
                        temp[__t_idx] = self.env[env_val]
                    end if
                    continue
                end if
            end for

            val = temp.join(" ")

            commands[__command_idx][__pipe_idx] = val
            cmd = val.split(" ")[0]

            // Check for history
            if val.is_match("^\^\d*.*$") then
                if self.session.history.len == 0 then continue

                parts = val.matches("^\^\d*(?=(\s|$))")
                if parts == {} then continue
                part = parts[0]

                if part == "^" then
                    commands[__command_idx][__pipe_idx] = val.replace("\^", self.session.history[-1])
                    has_history = true
                    continue
                end if

                history_index = part[1:].to_int
                if self.session.history.len <= history_index then continue
                has_history = true
                commands[__command_idx][__pipe_idx] = val.replace("\"+part, self.session.history[-(history_index+1)])
            
            // Check for aliases
            else if self.settings.hasIndex("alias") and self.settings.alias.hasIndex(cmd) then
                commands[__command_idx][__pipe_idx] = self.settings.alias[cmd] + " " + val.split(" ")[1:].join(" ")
                has_history = true
            end if
        end for
    end for

    joined = []
    for cmd in commands 
        joined.push(cmd.join(" | "))
    end for
    joined = joined.join(" && ")

    result = {}
    result.parsed = commands
    result.string = joined

    if has_history then return self.parse_command(joined)

    return result
end function


Kernel.run_command = function(text, add_to_history=true, silent=false)
    commands = self.parse_command(text)
    if (self.session.history.len > 0 and self.session.history[-1] != commands.string) or self.session.history.len == 0 then
        if add_to_history then
            self.session.history.push(commands.string)
        end if
    end if

    prev_silent = self.silent
    self.silent = silent
    good_result = true

    if self.DEBUG then
        e = []
        print(commands.string)
        print(commands.parsed)
    end if

    for command in commands.parsed
        self.piped = command.len > 1
        self.old_stdout = self.stdout.values
        self.stdout = []
        self.last_error = null
        self.quit_pipe = false
        had_success = false
        redircted = false
        fullRedirect = false
        redirectFile = null
        for pipe in command
            if self.quit_pipe then break
            parts = parse_input(pipe, true)
            if self.DEBUG then print(pipe)

            if len(parts) == 0 then continue

            cmd = parts[0].value
            cmd_obj = null

            // DEBUG STUFF
            if self.DEBUG then
                e = []
                for p in parts
                    e.push(p.eval_value)
                end for
                print(e)
            end if

            if self.commands.hasIndex(cmd) then
                cmd_obj = self.commands[cmd]

            else if self.tools.hasIndex(cmd) then
                cmd_obj = self.tools[cmd]

            else
                print("Command not found: " + cmd)
                good_result = false
                break
            end if
            if parts.len > 1 and parts[-2].value == ">>" or parts[-2].value == ">" then
                if parts[-2].value == ">" then fullRedirect = true
                redircted = true
                sessf = self.session.file
                path = parts[-1].eval_value
                temp = sessf.get_file(parts[-1].eval_value)
                if path[0] != "/" then path = sessf.path + "/" + path
                comp = self.session.computer
                if comp and is_error(temp) then 

                temp = comp.touch(parent_path(path),path.split("/")[-1])
                temp = sessf.get_file(path)

                end if

                if is_error(temp) then
                    redircted = false
                    self.last_error = temp.stack("Kernel.run_command")
                    continue
                end if
                
                redirectFile = temp
                if not fullRedirect then

                if not redirectFile.has_permission("rw") then
                redircted = false
                self.last_error = temp.stack("Kernel.run_command")
                continue
                end if

                else 
                    if not redirectFile.has_permission("w") then
                        redircted = false
                        fullRedirect = false
                        self.last_error = temp.stack("Kernel.run_command")
                        continue
                        end if
                end if
                for x in range(0,1)
                parts.pop()
                end for
            end if
            if __pipe_idx == 0 then
                pd = self.piped
                if redircted then self.piped = true
                result = cmd_obj.call(self, parts[1:])
                if redircted then 
                    self.piped = pd
                    prev = ""
                    if not fullRedirect then prev = redirectFile.get_content + char(10)
                    redirectFile.set_content(prev + unformat_string(self.stdout.join(char(10))))
                    redircted = false
                    fullRedirect = false
                end if
                if not is_error(result) then 
                    had_success = true
                else
                    self.last_error = result.stack("Kernel.run_command")
                end if

                if result isa string then
                    self.print(result)
                end if
            else
                was_piped = self.piped
                if __pipe_idx == command.len - 1 then self.piped = false

                self.old_stdout = self.stdout.values
                self.stdout = []
                for x in self.old_stdout
                    parts_2 = parse_input(unformat_string(x.trim), true)

                    result = cmd_obj.call(self, parts[1:] + parts_2)
                    if not is_error(result) then 
                        had_success = true
                    else
                        self.last_error = result.stack("Kernel.run_command")
                        print(self.last_error.trace())
                    end if
                end for
            end if

            if not self.raw_piped then
                for x in self.stdout
                    self.stdout[__x_idx] = """" + x.replace("""", """""") + """"
                end for
            end if
            self.raw_piped = false
        end for

        if not had_success then
            good_result = false
        end if
        if not had_success and self.last_error != null and not silent then
            if self.DEBUG then
                print(self.last_error.trace)
            else
                print(self.last_error.message)
            end if
            break
        end if
    end for

    self.silent = prev_silent
    return good_result
end function


Kernel.load_tools = function()
    custom_obj = get_custom_object
    self.tools = {}
    self.commands = {}

    shell = self.sessions[0].shell
    comp = shell.host_computer
    folders = comp.File("/etc/crow/tools")
    if folders isa Error then exit(folders.stack("Kernel.load_tools").trace)

    for x in folders.get_files
        self.print("$P;Loading $T2;<b>" + x.name)

        custom_obj.result = []
        shell.launch(x.path, "init")
        if custom_obj.result == [] then
            print("    <#f00>Failed to import tool")
            continue
        end if

        result = get_custom_object.result
        for tool in result
            tool._kernel = self
            self.tools[tool.name] = tool

            if hasIndex(tool, "settings") and tool.settings != null then
                save = false
                for category in tool.settings.data
                    cat = category.key
                    if not hasIndex(self.settings, cat) then
                        self.settings[cat] = {}
                    end if
                    for setting in category.value
                        if not hasIndex(self.settings[cat], setting.key) then
                            self.settings[cat][setting.key] = setting.value
                            self.raw_settings = self.raw_settings + char(10) + cat + " " + setting.key + " = " + setting.value
                            save = true
                        end if
                    end for
                end for
                if save then self.save_settings()
            end if

            for command in tool.commands
                if not command.value.standalone then continue
                self.commands[command.key] = command.value
            end for

            if tool.hasIndex("on_load") then
                result = tool.on_load(self)
                if is_error(result) then
                    self.print("    "+OsError.New(tool.name+".on_load", result.message).trace)
                end if
            end if

            self.print("    "+ "$T;Loaded $T2;" + "$T2;(" + tool.version + ")<b> $S;" + tool.name + " $T2;" + tool.loaded_commands + " $T;/$T2; " + tool.total_commands)
 
            custom_obj.remove("result")
        end for
    end for
    print(" ")
    self.print("$P;Loaded a total of $S;<b>" + self.tools.len + " </b>$P;tools.")
end function


Kernel.load_settings = function(path="/etc/crow/data/settings.txt")
    shell = self.sessions[0].shell
    comp = shell.host_computer
    file = shell.File(path)
    settings = {}

    if is_error(file) then
        if path == "/etc/crow/data/settings.txt" then
            print("Saving default settings to " + path)
            result = comp.touch("/etc/crow/data", "settings.txt", SETTINGS_DEFAULT)
            if result isa Error then return result.stack("Kernel.load_settings")

            error = self.load_settings(path)
            return error
        else
            return file
        end if
    end if

    raw_settings = file.get_content
    if is_error(raw_settings) then return raw_settings.stack("Kernel.load_settings")

    settings = raw_settings.split(char(10))
    out = {}
    for i in range(0, settings.len-1)
        line = settings[i].trim

        if line == "" then continue
        if line[:2] == "//" then continue

        data = line.split("=")
        if data.len < 2 then
            print(Error.New("(Settings)", "Invalid format: '"+line+"' on line "+i+". Skipping").message)
            continue
        end if
        
        setting_vars = data[0].trim.split(" ")
        if setting_vars.len != 2 then
            print(Error.New("(Settings)", "Invalid assignment : '"+line+"' on line "+i+". Skipping").message)
            continue
        end if

        category = setting_vars[0]
        key = setting_vars[1]
        value = data[1:].join("=").trim

        if out.indexes.indexOf(category) == null then out[category] = {}

        out[category][key] = value
    end for

    self.raw_settings = raw_settings
    self.settings = out
end function


Kernel.save_settings = function()
    user_settings = self.sessions[0].homepath
    
    f = self.sessions[0].file.get_file(user_settings+"/.crowrc")
    if is_error(f) then return f.stack("Kernel.save_settings")

    f.set_content(self.raw_settings)
end function


Kernel.get_prompt = function()
    type = "file"
    suffix = self.settings.input.file

    if self.session.shell != null then
        type = "shell"
        suffix = self.settings.input.shell
    else if self.session.computer != null then
        type = "comp"
        suffix = self.settings.input.computer
    end if

    status = self.settings.color.status_none + "None"
    
    if self.session == self.active_session then
        status = self.settings.color.status_active + "Active"
    else if self.active_sessions.indexOf(self.session) != null then
        status = self.settings.color.status_parses + "Parses"
    else if self.session != self.active_session then
        status = self.settings.color.status_jumped + "Jumped"
    end if

    ip = "Unknown"
    if self.session.wan != null then
        ip = self.session.wan
    end if

    user = self.session.user
    user = user.replace("^root$", self.settings.color.root + "root")

    raw_prompt = self.settings.input.prompt
    raw_prompt = raw_prompt.replace("\$usr", user)
    raw_prompt = raw_prompt.replace("\$comp", self.session.comp_name)
    raw_prompt = raw_prompt.replace("\$pwd", self.session.file.path)
    raw_prompt = raw_prompt.replace("\$type", type)
    raw_prompt = raw_prompt.replace("\$status", status)
    raw_prompt = raw_prompt.replace("\$suffix", suffix)
    raw_prompt = raw_prompt.replace("\$session", self.settings.color.session + self.session.id)
    raw_prompt = raw_prompt.replace("\$ip", self.settings.color.ip_prompt + ip)
    // raw_prompt.replace("\$pwd", self.active_session.file.path)
    return self.color(raw_prompt)
end function


// Kernel API functions for tools
Kernel.color = function(object)
    if not object isa list then
        object = "" + object
    end if
    if not object isa string and not object isa list then return TypeError.New("kernel_color", "string | list[string]", typeof(object))
    
    if object isa list then
        result = []
        for text in object
            new_text = self.color(text)
            if new_text isa Error then return new_text.stack("Kernel.color")
            result.push(new_text)
        end for
        return result
    else
        result = object
        if not self.settings.hasIndex("color") then return Error.New("kernel_color", "Color not found in settings")

        for color in self.settings["color"]
            result = result.replace("\$"+color.key+";", color.value)
        end for
        return result
    end if
end function


Kernel.print = function(msg, clear)
    seperated = self.color(str(msg)).split(char(10))
    self.stdout = self.stdout + seperated
    if not self.piped and not self.silent then print(self.color(msg), clear)
end function


Kernel.line = function(title, length)
    sep = floor((length - title.len - 4)/2)
    if title == "" then 
        self.print("$T;" + "—"*length)
    else
        self.print(("$T;" + "—"*sep + "(<b>$T2; " + title + "</b> $T;)" + "—"*sep))
    end if
end function


Kernel.check_update = function(interface_version)
    ver_string = []
    for x in self.tools.values
        ver_string.push(x.name + "@" + x.version)
    end for

    ver_string.push("kernel@" + self.version)
    if interface_version then ver_string.push("interface@"+interface_version)

    print(" ")
    self.print("$P;Checking for updates...")
    self.print("$P;Connecting to crowsploit servers $T;(159.139.90.130:69)")
    result = self.sessions[0].shell.connect_service("159.139.90.130", 69, "versioncheck", "versioncheck", "ssh")
    if is_error(result) then return result.stack("kernel.check_update")

    result.launch("/home/versioncheck/check",ver_string.join(" "))
end function

// Environment functions

Kernel.env.RAND_IP = function()
    return ""+random(1,255)+"."+random(0,255)+"."+random(0,255)+"."+random(0,255)
end function