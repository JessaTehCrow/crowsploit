import_code("../kernel/toolkernel")
import_code("../constants/example_macro")

// Define new tool
macroutils = Tool.New("macro", "1.3.2")
macroutils.short_description = "Macro utilities"
macroutils.long_description = "Utilities to create and use macros.
Macros are text files in <b>/etc/crow/macros/</b> filled with commands.
Each command is seperated by a newline.

<b>$S;<u>Thanks to Jaded for creating the base for this tool!</u></b>"

valid_name = function(text)
    valid = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"
    for x in text
        if valid.indexOf(x) == null then return false
    end for
    return true
end function

version_greater = function(v1, v2)
    v2_split = v2.split("\.")

    for x in v1.split("\.")
        if to_int(x) > to_int(v2_split[__x_idx]) then
            return true
        else if to_int(x) < to_int(v2_split[__x_idx]) then
            return false
        end if
    end for
end function

check_dependency = function(kernel, tool, op, version)
    for x in kernel.tools
        if x.key != tool then continue
        x = x.value

        raw_vers = x.version
        vers = raw_vers.matches("\d+\.\d+\.\d+").values
        if len(vers) == 0 then return [true, "Tool does not have x.x.x version format, continuing without check"]
        vers = vers[0]

        check_greater = (op == ">=")
        greater = version_greater(vers, version)
        if greater == null then return [true, ""]

        if not greater and check_greater then
            return [false, "Tool outdated. Need " + tool + " >= " + version + " got " + vers]
        else if greater and not check_greater then
            return [false, "Tool too new. Need " + tool + " <= " + version + " got " + vers]
        else if greater == check_greater then
            return [true, ""]
        end if
    end for

    return [false, "Dependency not found"]
end function


ParseMacroError = new Error
ParseMacroError.New = function(name, line_num, msg)
    error = new self
    error.stacktrace = []
    error.message = type_col + "(ParseMacroError) " + text_col + "[line " + line_num + "] " + name + " " + msg
    return error
end function

MacroError = new Error
MacroError.New = function(name, msg)
    error = new self
    error.stacktrace = []
    error.message = type_col + "(MacroError) " + text_col + name + " " + msg
    return error
end function

Macro = {}
Macro.name = null
Macro.desc = null
Macro.args = null
Macro.deps = null

Macro.New = function()
    m = new self
    m.name = null
    m.desc = "Macro default description"
    m.args = []
    m.commands = []
    m.deps = []
    return m
end function

Macro.set = function(line, linenum)
    sep = line.split(":")
    if len(sep) < 2 then return ParseMacroError.New("macro.set", linenum, "Identifier format: <b>@ key : value</b>")
    key = sep[0][1:].trim
    value = line[len(sep[0])+1:].trim
    log("macro identifier : '"+key + "'")
    log("macro iden value : '" + value + "'")

    if key == "name" then
        if not valid_name(key) then
            return ParseMacroError.New("macro.set_name", linenum, "Macro name must be alphanumeric (letters, digits, or '_')")
        end if
        self.name = value

    else if key == "desc" then
        self.desc = value

    else if key == "dep" then
        info = value.split(" ")
        format_err = ParseMacroError.New("macro.set_dependency", linenum, "Dependency format must follow: $T2;<b>@ dep : [tool] (<= | >=) x.x.x</b>")
        if len(info) != 3 then return format_err
        tool = info[0]
        op = info[1]
        ver = info[2]

        if ["<=",">="].indexOf(op) == null then return format_err
        if not ver.is_match("^\d+\.\d+\.\d+$") then return format_err
        
        log(tool)
        log(op)
        log(ver)
        self.deps.push({
            "tool":tool,
            "op":op,
            "version":ver
        })
    end if
end function

Macro.argument = function(line, linenum)
    // Expected input:
    // $argname : type = description
    // or
    // $argname : type

    sep = line.split(":")
    if len(sep) < 2 then return ParseMacroError.New("macro.argument", linenum, "Invalid argument format. Expected: <b>$name : type = description</b>")

    key = sep[0][1:].trim
    log("arg name '"+key+"'")
    if not valid_name(key) then return ParseMacroError.New("macro.argument", linenum, "Argument name must be alphanumeric (letters, digits, or '_')")
    
    type = sep[1].split("=")[0].trim
    log("arg type " + type)
    if ["string", "bool", "int", "float", "ip"].indexOf(type) == null then return ParseMacroError.New("macro.argument", linenum, "Invalid argument type. Must be one of string,bool,int,float,ip")

    desc = "Default argument description"
    // if = is detected, fetch description
    if line.indexOf("=") != null then
        desc = line[line.indexOf("=")+1:].trim
    end if
    log("arg desc: '"+desc + "'")

    self.args.push({"name":key, "type":type, "desc":desc})
end function

Macro.run = function(kernel, args=[])
    is_bool = function(v)
        if not v isa number then return false
        return v == 0 or v == 1
    end function

    if len(args) > len(self.args) then
        return MacroError.New("macro.run", "Too many arguments")
    else if len(args) < len(self.args) then
        return MacroError.New("macro.run", "Not enough arguments")
    end if

    log(args)
    for x in self.args
        arg = args[__x_idx]

        log("arg : " + arg + "   " + typeof(arg))

        // Map strings to values
        // [parsed_value, datatype]
        //      "true" -> [1, "bool"]
        //      "23.13" => [23.13, "float"]
        temp = EvalType.New(arg)

        // Remap value types if they can be shared
        if x.type == "string" then 
            temp.eval_value = temp.value
            temp.type = "string"
        end if

        if x.type == "float" and temp.type == "int" then temp.type = "float"

        log(x)
        log(temp)

        // If types don't match
        if x.type != temp.type then
            return MacroError.New("macro.run", "Invalid argument. Expected "+x.type+" got " + arg)
        end if

        kernel.env[x.name] = temp.eval_value
    end for

    for line in self.commands
        command = line[0]
        line_num = line[1]

        if kernel.env.hasIndex("silence") then
            if is_bool(kernel.env.silence) then silence = kernel.env.silence
        else
            silence = false
        end if
        if kernel.env.hasIndex("history") then
            if is_bool(kernel.env.history) then history = kernel.env.history
        else
            history = true
        end if
        
        success = kernel.run_command(command, history, silence)
        if not success then return line_num
    end for
end function

Macro.check_dependencies = function(kernel)
    for x in self.deps

        // [false, reason]
        // [true,  reason]
        res = check_dependency(kernel, x.tool, x.op, x.version)
        
        log(res)
        if res[0] == false then
            return MacroError.New("macro.check_dependency", res[1])
        end if
        if res[0] and res[1] != "" then
            _print(kernel.color("$error;" + res[1]))
        end if
    end for
    return true
end function


parse_macro = function(file)
    // very crude, but it works

    content = file.get_content

    // What parts have already been done
    // identifiers, arguments
    done = []

    // Expect is what to expect next
    // identifiers, arguments, commands 
    expect = null
    stack_command = false

    macro = Macro.New()

    for x in content.split(char(10)) 
        if x == "" then 
            // Can't have stacked commands followed by empty lines
            if stack_command then return ParseMacroError.New("macro.parse", __x_idx, "Empty line after stacked command")
            continue
        end if
        if x.matches("^//.*") then continue

        // Parse identifiers (name & desc)
        if x[0] == "@" then
            // Check if identifiers have been parsed before
            if done.indexOf("identifier") != null then return ParseMacroError.New("macro.parse", __x_idx, "Macro identifiers should be right after eachother")

            // If there's nothing to be expected
            // then set expectations to be more identifiers

            // If expected is arguments, then move that to done, and we should never expect arguments again
            if expect == null then 
                expect = "identifier"
            else if expect != "identifier" then
                done.push(expect)
                expect = "identifier"
            end if

            // Set identifier
            result = macro.set(x, __x_idx)
            if is_error(result) then return result.stack("macro.parse")

        // Parse variables
        else if x[0] == "$" then
            // Check if identifiers have been parsed before
            if done.indexOf("args") != null then return ParseMacroError.New("macro.parse", __x_idx, "Macro arguments should be right after eachother")
            // Check if this is defined After parsing commands
            if expect == "command" then return ParseMacroError.New("macro.parse", __x_idx, "Cannot define arguments after commands")

            // If there's nothing to be expected
            // then set expectations to be more arguments

            // If expected is arguments, then move that to done, and we should never expect identifiers again
            if expect == null then 
                expect = "args"
            else if expect != "args" then
                done.push(expect)
                expect = "args"
            end if

            result = macro.argument(x, __x_idx)
            if is_error(result) then return result.stack("macro.parse")

        // Parse commands
        else
            // Only allow commands if we've done identifiers before
            // Arguments are exempt from this, since not all macros need arguments
            if expect != "command" and expect != null then
                done.push(expect)
                expect = "command"
            end if
            if done.indexOf("identifier") == null then return ParseMacroError.New("macro.parse", __x_idx, "Commands cannot be before identifiers")
            
            // Stack commands are lines that end in `\`
            // these lines should be combines into one command line
            if stack_command then
                macro.commands[-1][0] = macro.commands[-1][0] + " " + x
            else
                macro.commands.push([x, __x_idx])
            end if

            stack_command = x.trim[-1] == "\"
            // If line is a stacked command, then make sure to remove the trailing \ from the actual command
            if stack_command then
                macro.commands[-1][0] = macro.commands[-1][0].trim()[:-1]
            end if
        end if
    end for

    if macro.name == null then
        return ParseMacroError.New("macro.parse", 0, "Macro must have a name defined")
    end if

    return macro
end function


load_macros = function(kernel, silent=false)
    ses = kernel.sessions[0]
    macro_folder = ses.file.get_folder("/etc/crow/macros")
    if is_error(macro_folder) then return macro_folder

    for f in macro_folder.get_files
        if not f.has_permission("r") and not silent then print("$error;Need read permission for macro: " + f.path)
        log("building macro '"+f.path+"'")
        macro = parse_macro(f)
        log(" ")
        if is_error(macro) then
            if not silent then print(macro.trace)
        else
            kernel.macros[macro.name] = macro
        end if
    end for
end function


macro_setup = function(k)
    // Ensure /etc/crow/macros exists
    // And also load existing macros
    if not k.hasIndex("macros") then 
        k.macros = {}
    end if

    homeshell = k.sessions[0].shell
    macrodir = homeshell.File("/etc/crow/macros/")

    if is_error(macrodir) then
        temp = homeshell.host_computer.create_folder("/etc/crow","macros")
        if is_error(temp) then return temp.stack("macroutils.main")
        macrodir = homeshell.File("/etc/crow/macros/")
        if is_error(macrodir) then return macrodir("macroutils.main")

        // Since folder is newly generated, we'll stuff the example_macro in here too
        k.sessions[0].computer.touch("/etc/crow/macros", "example")
        wait(0.1)
        f = homeshell.File("/etc/crow/macros/example")
        if not is_error(f) then f.set_content(example_macro)
    end if
end function


macroutils.on_load = function(k)
    macro_setup(k)
    return load_macros(k, true)
end function


run_args = [
    OptionalArg.New("name","string").Info("The name of the macro to run"),
    RestArg.New(),
]

run_func = function(a)
    macro_name = null
    if a.kernel.env.hasIndex("defaultmacro") then macro_name = a.kernel.env["defaultmacro"]
    if a.name != null then macro_name = a.name

    if not a.kernel.macros.hasIndex(macro_name) then return KernelError.New("macro.run", "Macro not found : " + macro_name)

    // Make a copy of the environment variables so we can reset it later
    // (If the macro overwrites existing env with its variables)
    env_copy = {}
    for x in a.kernel.env
        env_copy[x.key] = @x.value
    end for

    a.kernel.env.silence = false
    a.kernel.env.history = false

    macro = a.kernel.macros[macro_name]
    dep_check = macro.check_dependencies(a.kernel)
    if is_error(dep_check) then return dep_check.stack("macro.run")

    result = macro.run(a.kernel, a.rest)

    if result isa number then
        print("$error;Error running macro at line " + result)
        if a.kernel.env.silence then
            print(a.kernel.last_error.trace)
        end if
    end if

    // Reset env variables (if overwritten) before handling potential error
    for x in macro.args
        if env_copy.hasIndex(x.name) then
            a.kernel.env[x.name] = @env_copy[x.name]
        else
            remove(a.kernel.env, x.name)
        end if
    end for

    // remove silence & history before handling potential error
    remove(a.kernel.env, "silence")
    remove(a.kernel.env, "history")

    if is_error(result) then return result.stack("macro.run")
end function

runcmd = macroutils.command("run", run_args, @run_func)
runcmd.short_description = "Run a macro"
runcmd.long_description = "Run the specified macro.
$T2;If no macro is specified, check the environment for a defaultmacro key.
$T2;If the environment does not have one, run default.
$T2;Macro commands can be added to your history by setting history to true/1 in env.
$T2;Macro output can be suppressed by setting silence to true/1 in env."



// Default

default_args = [
    OptionalArg.New("name","string").Info("The name of the macro to set as the default").Default("default"),
]

default_func = function(a)
    if a.name == "default" then
        print("$P;Success!")
        return remove(a.kernel.env, "defaultmacro")
    end if

    homeshell = kernel.sessions[0].shell
    macrodir = homeshell.File("/etc/crow/macros/")

    if is_error(macrodir) then
        temp = homeshell.host_computer.create_folder("/etc/crow","macros")
        if is_error(temp) then return temp.stack("macroutils.main")
        macrodir = homeshell.File("/etc/crow/macros/")
    end if

    if is_error(macrodir.get_files) then return macrodir.get_files.stack("macroutils.main")
    if is_error(homeshell.File("/etc/crow/macros/"+a.name)) then return homeshell.File("/etc/crow/macros/"+a.name).stack("macroutils.run")

    a.kernel.env.defaultmacro = a.name
    print("$P;Success!")
end function

defaultcmd = macroutils.command("default", default_args, @default_func)
defaultcmd.short_description = "Set the default macro used by macro run"
defaultcmd.long_description = "Set the default macro used by macro run,
$T2;this is done by setting the defaultmacro key in the environment.
$T2;You don't <i>technically</i> need this, but it validates things and is more user-friendly."

// main

main_args = [
    OptionalArg.New("macro", "string").Info("Name of the macro for more info")
]

main_func = function(a)
    macro_setup(a.kernel)
    if a.macro != null then
        if not a.kernel.macros.hasIndex(a.macro) then return OsError.New("macro.main", "Macro not found")
        macro = a.kernel.macros[a.macro]
        print("$P;<size=30px>" + macro.name + "</size>")
        print("$T2;" + macro.desc)

        tabdata = []
        for x in macro.args
            tabdata.push([x.name, a.kernel.color("$"+x.type+";"+x.type), x.desc])
        end for
        
        res = tabulate_data(tabdata, ["Argument", "Type", "Description"], a.kernel.color(["$S;", "$T;", "$T2;"]))

        print(a.kernel.line("Dependencies", res.length))
        for x in macro.deps
            print("$P;"+x.tool + "$T2; " + x.op + "$S; " + x.version)
        end for
        print(a.kernel.line("Arguments", res.length))
        print(res.string)
        print(a.kernel.line("", res.length))
    else
        tabdata = []
        for x in a.kernel.macros
            macro = x.value
            args = []
            for arg in macro.args
                args.push(a.kernel.color("$"+arg.type+";"+arg.name))
            end for
            tabdata.push([macro.name, args.join("  "), macro.desc])
        end for
        result = tabulate_data(tabdata, ["Macro", "Arguments", "Description"], a.kernel.color(["$S;", "$T;", "$T2;"]))
        if is_error(result) then return result.stack("macro.main")
        print(result.string)
    end if
end function

maincmd = macroutils.main_command(main_args, @main_func)
maincmd.short_description = "Shows help for available macros"
maincmd.long_description = "Shows all available macros in <b>/etc/crow/macros/</b>
$P;Usage:

$P;macro
$P;macro example"

// reload

reload_args = []
reload_func = function(a)
    a.kernel.macros = {}
    res = load_macros(a.kernel, false)
    if is_error(res) then return res.stack("macro.reload")
    a.kernel.run_command("macro", false)
end function

reload_cmd = macroutils.command("reload", reload_args, @reload_func)
reload_cmd.short_description = "Reload macros into kernel"
reload_cmd.long_description = "$P;Usage:
$T2;Reloads macros from <b>/etc/crow/macros</b>
$P;macro reload"

macroutils.init()