import_code("../kernel/toolkernel")
import_code("../libs/sessionmanager")
import_code("../libs/syntax_parser")
import_code("../libs/tmp")

mytool = Tool.New("system", "1.10.5")

mytool.short_description = "All default system commands"
mytool.long_description = "All default system commands"

settings = Settings.init()
settings.set("color", {
    "P"     : "<#08f>",
    "S"     : "<#0cc>",
    "T"     : "<#669>",
    "T2"    : "<#99c>",
    "input" : "<#bcf>",
    "root"  : "<#f60>",
    "error" : "<#e05>",
    "lsfolder"  : "<#08f>",
    "lsbinary"  : "<#0e8>",
    "lsfile"    : "<#aad>",
    "lsdata"    : "<#99c>",
    "lsuser"    : "<#99c>",
    "lscode"    : "<#fc1>",
    "lssymlink" : "<#c158d6>",
    "string" : "<#d63>",
    "int"    : "<#39d>",
    "float"  : "<#b5e>",
    "bool"   : "<#35f>",
    "ip"     : "<#d44>",
    "rest"   : "<#557>",
    "status_active" : "<#c80>",
    "status_jumped" : "<#7c7>",
    "status_parses" : "<#c4c>",
    "status_none"   : "<#669>",
    "session"       : "<#669>",
    "ip_prompt"     : "<#d44>",
    "good"  : "<#4c4>",
    "bad"   : "<#c44>",
})

settings.set("input", {
    "prompt":"<voffset=2em> </voffset><pos=0><size=85%><voffset=1.4em>$S;$type $status $session $ip</voffset><pos=0></size>$T;($pwd) $P;$usr$T;@$S;$comp $T2;$suffix$input;",
    "shell" : ">",
    "computer" : ":",
    "file" : "-",
})

settings.set("alias", {
    "c":"clear",
    "la":"ls -la",
})

settings.set("library", {
    "path" : "/etc/crow/libs",
    "auto_update_meta" : "true",
    "auto_install" : "true"
})

settings.set("update", {
    "check" : "true"
})

settings.set("interface", {
    "streamer_mode" : "false",
    "temp_path"     : "/etc/crow/tmp"
})

mytool.settings = settings


// Clear screen //

clear_func = function(a)
    clear_screen()
end function

clearcmd = mytool.standalone_command("clear", [], @clear_func)
clearcmd.short_description = "Clears screen"
clearcmd.long_description = "$P;Examples:
$S;clear"



// Help //

help_args = [
    OptionalArg.New("tool|command", "string").Info("Help for build in command or tool"),
    OptionalArg.New("command",      "string").Info("Help for tool command"),
    Kwarg.New("small", "bool").Alias("s").Info("Small help output (Only for the main)")
]

help_func = function(a)
    arg_colors = function(command)
        result = []
        for x in command.args.args
            temp = "$" + x.type + ";" + x.name
            if x.optional then
                temp = temp + "?"
            end if

            if x.default != null then
                temp = temp + "$T;:$T2;" + x.default
            end if
            result.push(temp)
        end for

        if command.has_rest then
            result.push("$rest;rest")
        end if

        for x in command.args.kwargs
            kwarg = x.value
            temp = "$" + kwarg.type + ";--" + kwarg.name
            if kwarg.alias != null then
                temp = "$" + kwarg.type +";-"+kwarg.alias
            end if
            if kwarg.default != null then
                if kwarg.type == "bool" then
                    temp = temp + "$T;:$T2;" + ["false","true"][kwarg.default]
                else
                    temp = temp + "$T;:$T2;" + kwarg.default
                end if
            end if
            result.push(temp)
        end for

        result = a.kernel.color(result)
        return result.join(" ")
    end function

    help_cmd = function(command, full=false)
        args = arg_colors(command)
        offset = -3
        if a.small then offset = 1
        if not full then return [command.name, args, command.short_description][:-offset]

        offset = -4
        if a.small then offset = 2

        // Arg tabulate
        arg_data = []
        for x in command.args.args
            type = a.kernel.color("$"+x.type+";"+x.type)
            arg_data.push([x.name, type, ["False","True"][x.optional], x.info][:-offset])
        end for
        arg_result = tabulate_data(arg_data, ["Name", "Type", "Optional", "Info"][:-offset], a.kernel.color(["$P;", "$T;", "$S;", "$T2;"]))

        // Kwarg tabulate
        kwarg_data = []
        for x in command.args.kwargs
            k = x.value
            type = a.kernel.color("$"+k.type+";"+k.type)
            alias = ""
            if k.alias then alias = "-" + k.alias
            kwarg_data.push(["--"+k.name, type, alias, k.info][:-offset])
        end for
        kwarg_result = tabulate_data(kwarg_data, ["Name", "Type", "Alias", "Info"][:-offset], a.kernel.color(["$P;", "$T;", "$S;", "$T2;"]))
        longest = max([arg_result.length, kwarg_result.length])

        // Displaying
        a.kernel.line("", longest)

        a.kernel.print("<size=30px>$P;" + command.name)
        a.kernel.print("$S;" + command.name + " " + arg_colors(command))

        // Display args
        a.kernel.line("Args", longest)
        a.kernel.print(arg_result.string)
        a.kernel.print(" ")

        // Display kwargs
        a.kernel.line("Kwargs", longest)
        a.kernel.print(kwarg_result.string)
        a.kernel.print(" ")

        // Display description
        a.kernel.line("Description", longest)
        a.kernel.print("$T2;" + command.short_description)
        a.kernel.print(" ")

        a.kernel.print("$T2;" + command.long_description)
        a.kernel.line("", longest)
    end function

    main = a["tool|command"]

    if main != null then
        if a.kernel.commands.hasIndex(main) then
            help_cmd(a.kernel.commands[main], true)

        else if a.kernel.tools.hasIndex(main) then
            main = a.kernel.tools[main]

            if a.command != null then
                if not main.commands.hasIndex(a.command) then return Error.New("(HelpError) Command not found: " + main.name + "." + a.command)
                help_cmd(main.commands[a.command], true)
            else
                tab_data = []
                for cmd in main.commands
                    tab_data.push(help_cmd(cmd.value))
                end for
                offset = -3
                if a.small then offset = 1
                result = tabulate_data(tab_data, ["name", "args", "description"][:-offset], a.kernel.color(["$S;", "$T2;", "$T2;"]), a.kernel.color(["<i>$T;"]))
                if result isa Error then return result.stack("system.help")

                a.kernel.line("", result.length)
                print("$P;<size=30px>" + main.name)
                print("$S;Version $T;: $int;" + main.version)
                print(main.long_description)
                a.kernel.line("Commands", result.length)
                print(result.string)
                a.kernel.line("", result.length)
            end if
        end if
    else
        tool_data = []
        for x in a.kernel.tools
            tool_data.push([x.value.name, x.value.short_description])
        end for
        tool_result = tabulate_data(tool_data, ["Name", "Description"], a.kernel.color(["$S;", "$T2;"]), a.kernel.color(["<i>$T;"]))

        offset = -3
        if a.small then offset = 1
        command_data = []
        for x in a.kernel.commands
            command_data.push([x.value.name, arg_colors(x.value), x.value.short_description][:-offset])
        end for
        command_result = tabulate_data(command_data, ["Name", "Args", "Description"][:-offset], a.kernel.color(["$S;", "$T;", "$T2;"]), a.kernel.color(["<i>$T;"]))


        longest = max([tool_result.length, command_result.length])

        a.kernel.line("Tools", longest)
        print(tool_result.string)
        print(" ")

        a.kernel.line("Commands", longest)
        print(command_result.string)
        print(" ")
        
        a.kernel.line("", longest)
    end if
end function

help = mytool.standalone_command("help", help_args, @help_func)
help.short_description = "List help for tools and commands"
help.long_description = "$P;Examples:
$S;help
$S;help $string;system
$S;help $string;system $string;help
$S;help $string;help"



// echo //

echo_args = [
    RestArg.New()
]

echo_funcs = function(a)
    print(a.rest.join(" "))
end function

echo_cmd = mytool.standalone_command("echo", echo_args, @echo_funcs)
echo_cmd.short_description = "Prints text to screen"
echo_cmd.long_description  = "$P;Examples:
$S;echo $string;Hello world!
$S;echo $string;How ""are you doing"" today?"



// cat //

cat_args = [
    Arg.New("file", "string").Info("File to print contents for"),
    Kwarg.New("force", "bool").Alias("f").Info("Use a game exploit to cat files you don't have access to"),
    Kwarg.New("format", "bool").Alias("m").Info("Format the output like it's greyscript")
]

cat_function = function(a)
    file = a.kernel.session.file.get_file(unformat_string(a.file))

    if is_error(file) then return file.stack("system.cat")
    if not file.is_file then return TypeError.New("system.cat", "file", file.file_type)
    if not file.has_permission("r") then
        if not a.force then
            return PermissionError.New("system.cat", "read")
        end if
        
        if a.kernel.session.shell == null then return ObjectError.New("system.cat (force)", "shell")
        log("Force cat activated")

        exploit_string = "get_custom_object.content=""import"+"_code("""+ file.path + """)"""
        pfile = a.kernel.session.file

        log("Finding file to create source")
        things = pfile.get_folder("/").find_permission("w", true)
        target = null
        for thing in things
            target = thing
            if thing.is_folder then break
        end for
        if target == null then return OsError.New("system.cat", "Cannot find writable folder for exploit")
        log("Path found: " + target.path)

        log("Creating file")
        a.kernel.session.computer.touch(target.path, "catthing.src")
        wait(0.02)
        log("Setting content")
        f = a.kernel.session.shell.File(target.path+"/catthing.src")
        f.set_content(exploit_string)
        wait(0.04)
        log("Building file")
        log(f.path)
        log(target.path)
        build_success = a.kernel.session.shell.build(f.path, target.path)
        log("result: " + typeof(build_success) + " : " + build_success)
        if build_success != "" then
            return Error.New("system.cat (forced)","Failed to compile code. Source file may have double quotes in it")
        end if
        log("Launching catthing")
        wait(0.02)
        a.kernel.session.shell.launch(target.path + "/catthing")
        ob = get_custom_object
        if hasIndex(ob, "content") and @ob["content"] isa string then
            print(get_custom_object.content)
            remove(get_custom_object, "content")
        end if
        return
    end if

    content = file.get_content
    if not a.kernel.piped then 
        if file.path[-3:] == "src" or a.format then
            result = parse_syntax(uncolor_string(content), true).replace("\\n", "\<b></b>n")
            seperated = result.split(char(10))
            steps = 400
            for x in range(0,ceil(len(seperated)/steps)-1)
                _print(seperated[x*steps:(x+1)*steps].join(char(10)))
                wait(0.1)
            end for 
        else
            _print(uncolor_string(content))
        end if
    end if

    for x in content.split(char(10)) 
        a.kernel.stdout.push(unformat_string(x))
    end for
end function

cat_cmd = mytool.standalone_command("cat", cat_args, @cat_function)
cat_cmd.short_description = "Print contents of file to terminal"
cat_cmd.long_description  = "$P;Examples:
$S;cat $string;/etc/passwd
$S;cat $string;/etc/apt/sources.txt -m"



// history //

history_args = [
    Kwarg.New("clear", "bool").Alias("c").Info("Clear history"),
    Kwarg.New("limit",  "int").Alias("l").Default(10).Info("Amount of history items to display"),
]

history_function = function(a)
    if a.clear == true then 
        a.kernel.session.history = []
        return
    end if

    if a.kernel.session.history == [] then return

    history = a.kernel.session.history[-a.limit:]
    for x in history
        print("$T2;"+(history.len-1-__x_idx) + "  $P;" + x)
    end for
end function

history_cmd = mytool.standalone_command("history", history_args, @history_function)
history_cmd.short_description = "Show command history"
history_cmd.long_description  = "$P;Examples:
$S;history
$S;history $bool;-clear
$S;history $int;-limit 30"



// Ls //

ls_args = [
    OptionalArg.New("path", "string").Info("Folder to list items from"),
    Kwarg.New("long",    "bool").Alias("l").Info("Show permissions, User and group"),
    Kwarg.New("all",     "bool").Alias("a").Info("Show hidden files and folders"),
    Kwarg.New("longall","bool").Alias("la").Info("Both --long and --all"),
]

ls_func = function(a)
    if a.longall then 
        a.long = true
        a.all = true
    end if

    ses_file = a.kernel.session.file
    if a.path != null then
        ses_file = ses_file.get_folder(a.path)
        if is_error(ses_file) then return ses_file.stack("system.ls")
    end if

    items = []
    for x in ses_file.get_all
        if x.name[0] == "." and not a.all then continue
        col = a.kernel.color("$ls"+x.file_type+";")
        extra = ""

        if x.file_type == "symlink" then
            real_file = ses_file.get_path(x.path(1))
            if is_error(real_file) then
                extra = "$T2; >> $T;" + "[deleted]"
            else
                extra = "$T2; >> $ls" + real_file.file_type + ";" + real_file.path
            end if
        end if

        filesize = round(to_int(x.size)/1048576, 2)
        
        items.push([col+x.name, x.permissions, x.path, x.owner.replace("root", "$root;root"), "$T;"+x.group.replace("root", "$root;root"), extra, filesize])
    end for

    if a.long then
        for x in items
            print("$lsdata;" + x[1] + " $T;"+x[6] + "MB $lsuser;" + x[3] + " $lsuser;" + x[4] + " " + x[0] + x[5])
        end for
    else
        result = []
        raw_temp = []
        col_temp = []
        for x in items
            if raw_temp.join("  ").len > 75 then
                result.push(col_temp.join("  "))
                col_temp = []
                raw_temp = []
            end if

            raw_temp.push(unformat_string(x[0]))
            col_temp.push(x[0])
        end for

        if raw_temp.len > 0 then
            result.push(col_temp.join("  "))
        end if

        print(result.join(char(10)))
    end if
end function

ls = mytool.standalone_command("ls", ls_args, @ls_func)
ls.short_description = "List files and directories"
ls.long_description = "$P;Examples:
$S;ls $bool;-l
$S;ls $bool;-a
$S;ls $bool;-la"



// CD //

cd_args = [
    OptionalArg.New("path", "string").Info("Path to change into")
]

cd_func = function(a)
    if a.kernel.session.file.status != 0 then
        a.kernel.session.file = a.kernel.session.root_path
        return KernelError.New("system.cd", "Path deleted or corrupted. Resetting to /")
    end if

    loc = a.path
    if a.path == null then loc = a.kernel.session.homepath

    p = Path.New(a.kernel.session.file.path)
    p.change(loc)

    file = a.kernel.session.file.get_folder(p.path)

    if is_error(file) then return file.stack("system.cd")
    if file.status then return OsError.New("system.cd", "Target folder is corrupt or deleted")

    a.kernel.session.file = file
end function

cd = mytool.standalone_command("cd", cd_args, @cd_func)
cd.short_description = "Change directory"
cd.long_description = "$P;Examples:
$S;cd $string;/etc
$S;cd $string;/usr/bin
$S;cd $string;/home/guest/Desktop"



// exit

exit_func = function(a)
    kernel = a.kernel
    session = kernel.session

    if kernel.active_sessions.indexOf(session) != null then
        if len(kernel.active_sessions) == 1 or kernel.session == kernel.active_sessions[0] then
            if confirmation_prompt("Are you sure you want to exit the tool?") then
                kernel.keep_session = false
            end if
        else if kernel.session != kernel.active_session then
            return OsError.New("system.exit", "Cannot exit parent session of current active session")
        else
            kernel.sessions.remove(kernel.sessions.indexOf(session))
            kernel.active_sessions.pop()
            kernel.active_session = kernel.active_sessions[-1]
            kernel.run_command("session use " + kernel.sessions[-1].id, false)
            print("$P;New active session$T2;: $S; " + kernel.session.id)
            exit()
        end if
    else
        kernel.sessions.remove(kernel.sessions.indexOf(kernel.session))
        kernel.run_command("session use " + kernel.active_session.id, false)
    end if
end function

_exit =  mytool.standalone_command("exit", [], @exit_func)
_exit.short_description = "Exit the current session"
_exit.long_description = "$P;Usage:
$P;exit"



// tree //

tree_args = [
    OptionalArg.New("path",   "string").Info("Path to tree from"),
    Kwarg.New("raw", "bool").Alias("r").Info("Show raw data. (Handy for piping)")
]

tree_func = function(a)
    file = a.kernel.session.file
    if a.path != null then
        file = file.get_folder(a.path)
        if is_error(file) then return file.stack("system.tree")
    end if

    sys_tree = file.tree(true)

    last_depth = 0
    for file in sys_tree
        if a.raw then
            print(file.path)
        else
            depth = file.path.count("/") - 1

            if depth < last_depth then
                print("$T;  |" * depth)
            end if

            pointer = "$T; "
            if file.is_folder then pointer = "$T;——Г "

            user = file.owner.replace("root", "$root;root")
            group = file.group.replace("root", "$root;root")
            file_color = a.kernel.color("$ls" + file.file_type + ";")
            extra = ""

            if file.file_type == "symlink" then
                original = file.get_path(file.path(1))
                if is_error(original) then
                    extra = "$T2; >> $T;" + "[deleted]"
                else
                    extra = "$T2; >> " + "$ls" + original.file_type + ";" + original.path
                end if
            end if

            filesize = round(to_int(file.size)/1048576, 2)

            print("$T;  |" *depth + pointer + "$lsdata;" + file.permissions + " $T;" + filesize + "MB $T;" + user + " $T;" + group + " " + file_color + file.name + extra)

            last_depth = depth
        end if
    end for
end function

tree = mytool.command("tree", tree_args, @tree_func)
tree.short_description = "Show the entire folder & file tree"
tree.long_description = "$P;Usage:
$S;system tree
$S;system tree $string;/home
$S;system tree $string;/etc $bool;--raw $string;
$S;system tree $bool;-r"



// grep

grep_args = [
    Arg.New("pattern",       "string").Info("Pattern to match"),
    Kwarg.New("invert",      "bool").Alias("v").Info("Don't match pattern"),
    Kwarg.New("regex",       "bool").Alias("e").Info("Enables regex"),
    Kwarg.New("ignore-case", "bool").Alias("i").Info("Disable case-sensitive matching"),
    Kwarg.New("highlight",   "bool").Alias("h").Info("Highlight matches"),
    Kwarg.New("isolate",     "bool").Alias("s").Info("Only display the match, and ignore everything else"),
    Kwarg.New("no-color",    "bool").Alias("c").Info("No color"),
    RestArg.New()
]

grep_function = function(a)
    if a.pattern == "" then return Error.New("system.grep", "pattern cannot be empty")
    text = a.rest.join(" ")
    if not a.regex then a.pattern = regex_escape(a.pattern)

    amount = null
    match = text
    result = null
    if a["ignore-case"] then
        a.pattern = a.pattern.lower
        match = match.lower
    end if

    if a["no-color"] or a.highlight then
        text = unformat_string(text)
    end if

    if not a.isolate then
        amount = unformat_string(match).matches(a.pattern).len

        if (a.invert and amount == 0) or (not a.invert and amount > 0) then
            result = text
        end if
    else
        parts = []
        if a.invert then
            parts = text.split(a.pattern)
        else
            parts = text.matches(a.pattern).values
        end if
        result = parts.join(char(10))
    end if

    if result == "" or result == null then return

    if a.highlight then
        if a.invert then
            result = a.kenrnel.color("$P;" + result)
        else
            matches = result.matches(a.pattern).values
            results = result.split(a.pattern)
            new_result = ""

            for i in results.indexes
                new_result = new_result + results[i]
                if matches.hasIndex(i) then new_result = new_result + "$P;" + matches[i] + "</color>"
            end for

            result = a.kernel.color(new_result)
        end if
    end if

    print(result)
end function

grep = mytool.standalone_command("grep", grep_args, @grep_function)
grep.short_description = "Match strings (Mostly used with piping)"
grep.long_description = "$P;Usage:
$S;tree $bool;--raw $T;| $S;grep $bool;-e $string;""Mail.txt|Bank.txt"""



// Find //

find_args = [
    OptionalArg.New("path", "string").Info("Path to start search from"),
    Kwarg.New("name",  "string").Alias("n").Info("Match Name with item"),
    Kwarg.New("perm",  "string").Alias("p").Info("Match permissions with item"),
    Kwarg.New("user",  "string").Alias("o").Info("Match user with item"),
    Kwarg.New("group", "string").Alias("g").Info("Match group with item"),
    Kwarg.New("type",  "string").Alias("t").Info("Match file type"),
    Kwarg.New("local", "bool").Alias("l").Info("Only find in current folder")
]

find_func = function(a)
    file = a.kernel.session.file

    if a.perm then
        err = file.has_permission(a.perm)
        if is_error(err) then return err.stack("system.find")
    end if

    if a.type and ["binary", "file", "folder", "code"].indexOf(a.type) == null then
        return FormatError.New("system.find", "binary, file, folder or code", a.type)
    end if

    if a.path then
        file = file.get_folder(a.path)
        if is_error(file) then return file.stack("system.find")
    end if

    sys_tree = file.tree((not a.local))
    if is_error(sys_tree) then return sys_tree.stack("system.find")

    result = 0
    for file in sys_tree
        if a.name and not file.name.is_match(a.name) then continue
        if a.type and file.file_type != a.type then continue
        if a.user and file.owner != a.user then continue
        if a.group and file.group != a.group then continue
        if a.perm and not file.has_permission(a.perm) then continue

        result = result + 1
        print("$ls"+file.file_type+";"+file.path)
    end for
    if result == 0 then return OsError.New("system.find","No matches found")
end function

find = mytool.standalone_command("find", find_args, @find_func)
find.short_description = "Find files based on attributes"
find.long_description = "$P;Usage:
$S;find $string;--perm rwx --user root
$S;find $string;--type binary -p rwx
$S;find $string;/bin"



// reload //

reload_args = [
    Kwarg.New("commands", "bool").Alias("c").Info("Reloads the commands"),
    Kwarg.New("settings", "bool").Alias("s").Info("Reloads the user settings"),
    Kwarg.New("full-reload", "bool").Default(true).Alias("f").Info("Completely unloads all tools and reloads them (Otherwise only overwrite)")
]

reload_func = function(a)
    user = a.kernel.sessions[0].user
    user_settings = "/home/" + user
    if user == "root" then
        user_settings = "/root"
    end if
    if not a.settings and not a.commands then
        a.settings = 1
        a.commands = 1
    end if

    if a.commands then
        a.kernel.load_tools(a["full-reload"])
    end if
    if a.settings then
        err = a.kernel.load_settings(user_settings + "/.crowrc")
        if is_error(err) then log(err.stack("system.reload").trace)
        if is_error(err) then 
            print("$error;Failed to load settings from " + user_settings + "/.crowrc")
        else
            print("$S;Loaded settings from " + user_settings + "/.crowrc")
        end if
    end if
end function

reload = mytool.command("reload", reload_args, @reload_func)
reload.short_description = "Reload commands or settings"
reload.long_description = "If neither --commands or --settings is provided, it reloads both.

$P;Usage:
$S;system reload
$S;system reload $bool;--commands
$S;system reload $bool;-s"



// move //

mv_args = [
    Arg.New("path", "string").Info("File to move"),
    Arg.New("new_path", "string").Info("Path to move to"),
    Kwarg.New("inverted", "bool").Alias("i").Info("Invert the direction of the move command")
]

mv_func = function(a)
    ses_file = a.kernel.session.file
    if a.inverted then
        temp = a.path
        a.path = a.new_path
        a.new_path = temp
    end if

    target = ses_file.get_path(a.path)
    if is_error(target) then return target.stack("system.mv")
    p = Path.New(target.path)
    if not target.parent.has_permission("w") then return PermissionError.New("system.mv", "write")
    if p.is_parent_of(ses_file.path) then return OsError.New("system.rm", "Cannot remove folder you are inside of")
    old_name = target.name
    filename = target.name
    
    new_path = ses_file.get_path(a.new_path)
    if not is_error(new_path) and not new_path.is_folder then
        filename = new_path.name
        new_path = new_path.parent
    end if

    if is_error(new_path) then
        np = Path.New(ses_file.path)
        np.change(a.new_path)

        folder = ses_file.get_folder(np.path)
        if is_error(folder) then
            parent_folder = ses_file.get_folder(np.folder)
            if is_error(parent_folder) then return parent_folder.stack("system.move")
            new_path = parent_folder
            filename = np.name
        else
            new_path = folder
        end if
    end if

    if is_error(new_path) then return new_path.stack("system.mv")
    if not new_path.has_permission("w") then return PermissionError.New("system.mv", "write")
    if filename.len >= 128 then return OsError.New("system.mv", "Filename cannot be above 128 characters")

    dir = new_path.path
    if dir != "/" then sep = "/" else sep = ""
    type = target.file_type
    err = target.move(dir, filename)
    if is_error(err) then return err.stack("system.mv")
    if err isa string then return Error.New(err)
    print("$T;Moved $ls" + type + ";" + old_name + " $T;to $ls" + type + ";" + dir + sep + filename)
end function

mv = mytool.standalone_command("mv", mv_args, @mv_func)
mv.short_description = "Move files / folders"
mv.long_description = "$P;Usage:
$S;mv $string;sources.txt /etc/apt/sources.txt
$S;mv $string;sources.txt /etc/apt/
$S;mv $string; /lib /root/kernel_router.so -i $T;<< Moves kernel_router.so to /lib instead"



// copy //

copy_args = [
    Arg.New("file", "string").Info("File to copy"),
    Arg.New("target", "string").Info("Target path"),
]

copy_func = function(a)
    ses_file = a.kernel.session.file
    target = ses_file.get_path(a.file)

    if is_error(target) then return target.stack("system.cp")
    if not target.has_permission("r") and a.file != "/" then return PermissionError.New("system.cp", "read")

    old_name = target.name
    filename = target.name

    log(old_name + " / " + filename)
    p = Path.New(ses_file.path)
    p.change(a.target)
    new_path = ses_file.get_path(p.path)

    if not is_error(new_path) and not new_path.is_folder then
        filename = new_path.name
        new_path = new_path.parent.path
    else if not is_error(new_path) then
        new_path = new_path.path
    else if is_error(new_path) then
        new_path = p.folder
        filename = p.name
    end if

    log(new_path + " / " + filename)

    if is_error(new_path) then
        if a.target.count("\/") == 0 then
            new_path = ses_file.path
        end if
        filename = a.target.split("/")[-1]
    end if
    //if typeof(new_path) != "string" then new_path = new_path.path
    // if is_error(new_path) then return new_path.stack("system.cp")
    // if not new_path.has_permission("w") then return PermissionError.New("system.cp", "write")
    if filename.len >= 128 then return OsError.New("system.cp", "Filename cannot be above 128 characters")

    //dir = new_path.path
    err = target.copy(new_path, filename)
    if is_error(err) then return err.stack("system.cp")
    if err isa string then return Error.New(err)
    print("$T;Copied $ls" + target.file_type + ";" + old_name + " $T;to $ls" + target.file_type + ";" + new_path + "/" + filename)
end function

copy = mytool.standalone_command("cp", copy_args, @copy_func)
copy.short_description = "Copy file to location"
copy.long_description = "$P;Usage:
$S;cp $string;/home/guest/malware /etc/init.d
$S;cp $string;/etc/apt/sources.txt /root"



// rm //

rm_args = [
    Arg.New("path", "string").Info("Path to remove"),
    Kwarg.New("recursive", "bool").Alias("r").Info("Recursive to remove folder"),
    Kwarg.New("silent","bool").Alias("s").Info("Silently remove file(doesnt leave logs)")
]

rm_func = function(a)
    ses_file = a.kernel.session.file
    
    target = ses_file.get_path(a.path)
    if is_error(target) then return target.stack("system.rm")
    p = Path.New(target.path)

    if not target.parent.has_permission("w") then return PermissionError.New("system.rm", "write")
    if target.is_folder and not a.recursive then return OsError.New("system.rm", "Unable to remove folder. Use --recursive to delete entire folder")
    if p.is_parent_of(ses_file.path) then return OsError.New("system.rm", "Cannot remove folder you are inside of")

    type = target.file_type
    if a.silent then 
        result = target.silent_rm()
        if is_error(result) then return result
    else
        result = target.delete()
        if is_error(result) then return result
    end if
    print("$T;Deleted $ls" + type + ";" + p.path)
end function

rm = mytool.standalone_command("rm", rm_args, @rm_func)
rm.short_description = "Remove file or folder"
rm.long_description = "$P;Usage:
$S;rm $string;/lib/kernel_module.so
$S;rm $string;/etc/passwd"



// touch //

touch_args = [
    Arg.New("name", "string").Info("File to create"),
    Kwarg.New("text", "string").Alias("t").Info("Text to set in the created file")
]

touch_func = function(a)
    if a.kernel.session.computer == null then return ObjectError.New("system.touch", "computer")
    ses_file = a.kernel.session.file
    ses_comp = a.kernel.session.computer

    // target = ses_file.get_file(a.name)
    // if not is_error(target) then return OsError.New("system.touch", "File already exists")

    p = Path.New(ses_file.path)
    p.change(a.name)

    err = ses_comp.touch(p.folder, p.name, a.text)
    if is_error(err) then return err.stack("system.touch")

    print("$T;Created file $lsfile;" + a.name)
end function

touch = mytool.standalone_command("touch", touch_args, @touch_func)
touch.short_description = "Create new file"
touch.long_description = "$P;Usage:
$S;touch $string;file.txt
$S;touch $string;/home/guest/Desktop/hello.txt
$S;touch $string;message.txt --text 'Hello there!'"



// mkdir

mkdir_args = [
    Arg.New("name", "string").Info("File to create")
]

mkdir_func = function(a)
    if a.kernel.session.computer == null then return ObjectError.New("system.mkdir", "computer")
    ses_file = a.kernel.session.file
    ses_comp = a.kernel.session.computer

    target = ses_file.get_path(a.name)
    if not is_error(target) then return OsError.New("system.mkdir", "Folder already exists")

    err = null
    if a.name[0] == "/" then
        err = ses_comp.create_folder(parent_path(a.name), a.name.split("/")[-1])
    else
        err = ses_comp.create_folder(ses_file.path, a.name)
    end if
    if is_error(err) then return err.stack("system.mkdir")

    print("$T;Created folder $lsfolder;" + a.name)
end function

mkdir = mytool.standalone_command("mkdir", mkdir_args, @mkdir_func)
mkdir.short_description = "Create new directory"
mkdir.long_description = "$P;Usage
$S;mkdir $string;newdir
$S;mkdir $string;/root/owo"



// Ps

ps_func = function(a)
    if a.kernel.session.computer == null then return ObjectError.New("system.ps", "computer")
    ses_comp = a.kernel.session.computer

    procs = ses_comp.show_procs
    result = []
    for x in procs.split(char(10))[1:]
        data = x.split(" ")
        data[0] = a.kernel.color(data[0].replace("^root$", "$root;root"))
        result.push(data)
    end for

    data = tabulate_data(result, ["User", "PID", "CPU", "MEM", "Command"], a.kernel.color(["$T2;", "$S;", "$T;", "$T;", "$P;"]))
    a.kernel.line("Processes", data.length)
    print(data.string)
    a.kernel.line("", data.length)
end function

ps = mytool.standalone_command("ps", [], @ps_func)
ps.short_description = "Show running processes"
ps.long_description  = "$P;Usage:
$S;ps"



// chown

chown_args = [
    Arg.New("option", "string").Info("New file info"),
    Arg.New("file", "string").Info("Target file"),
    Kwarg.New("recursive", "bool").Default(false).Alias("r").Info("Recursively set new owner & group")
]

chown_func = function(a)
    ses_file = a.kernel.session.file
    p = Path.New(ses_file.path)
    p.change(a.file)

    target = ses_file.get_path(p.path)
    if is_error(target) then return target.stack("system.chown")
    if not target.has_permission("w") then return PermissionError.New("system.chown", "write")

    raw = a.option.split(":")
    if raw.len > 2 then return Error.New("Invalid format. use 'user:group'")

    user = raw[0]
    group = ""
    if raw.len == 2 then group = raw[1]

    if user then
        err = target.set_owner(user, a.recursive)
        if is_error(err) then return err.stack("system.chown")
    end if
    if group then
        err = target.set_group(group, a.recursive)
        if is_error(err) then return err.stack("system.chown")
    end if

    print("$T;Set new permissions to $P;" + a.option)
end function

chown = mytool.standalone_command("chown", chown_args, @chown_func)
chown.short_description = "Change file owner / group"
chown.long_description = "$P;Usage:
$S;chown $string;user:group file.txt
$S;chown $string;root:root file.txt
$S;chown $string;user file.txt"



// chmod

chmod_args = [
    Arg.New("option", "string").Info("New file info"),
    Arg.New("file", "string").Info("Target file"),
    Kwarg.New("recursive", "bool").Default(false).Alias("r").Info("Recursively set permission")
]

chmod_func = function(a)
    ses_file = a.kernel.session.file
    p = Path.New(ses_file.path)
    p.change(a.file)
    target = ses_file.get_path(p.path)
    if is_error(target) then return target.stack("system.chmod")
    //if not target.has_permission("w") then return PermissionError.New("system.chmod", "write")
    err = target.chmod(a.option, a.recursive)
    if is_error(err) then return err.stack("system.chmod")
    print("$T;Set new permissions to $P;" + target.permissions)
    return true
end function

chmod = mytool.standalone_command("chmod", chmod_args, @chmod_func)
chmod.short_description = "Change file permissions"
chmod.long_description = "$T;Format: $S; [oug][-+][rwx]
           $S; 000-777

$P;Usage:
$S;chmod $string;777 file.txt
$S;chmod $string;432 file.txt
$S;chmod $string;o+w file.txt
$S;chmod $string;o+ file.txt
$S;chmod $string;+ file.txt
$S;chmod $string;uo+x file.txt
$S;chmod $string;uo+xw file.txt
$S;chmod $string;o=rw file.txt
$S;chmod $string;o-rwx file.txt
$S;chmod $string;g-w file.txt
$S;chmod $string;u-rw file.txt"



// groups

groups_args = [
    Arg.New("user", "string").Info("User to check groups from")
]

groups_func = function(a)
    if a.kernel.session.computer == null then return ObjectError.New("system.groups", "computer")
    result = a.kernel.session.computer.groups(a.user)
    if not result then return OsError.New("system.groups", "No user found with name '"+a.user+"'")
    if is_error(result) then return result.stack("system.groups")
    print(result.split(char(10))[:-1].join(", "))
end function

groups = mytool.command("groups", groups_args, @groups_func)
groups.short_description = "Get groups for user"
groups.long_description = "$P;Usage:
$S;system groups $string;root
$S;system groups $string;guest"



// iwlist

iwlist_func = function(a)
    if a.kernel.session.computer == null then return ObjectError.New("system.iwlist", "computer")
    comp = a.kernel.session.computer

    wifis = comp.wifi_networks("wlan0")

    if wifis == null then return OsError.New("system.iwlist", "No wifi card found")

    tab_data = []
    for x in wifis
        if not x isa string then continue
        tab_data.push(x.split(" "))
    end for
    result = tabulate_data(tab_data, ["BSSID", "PWR", "ESSID"], a.kernel.color(["$T2;", "$S;", "$P;"]))

    a.kernel.line("Networks", result.length)
    print(result.string)
    a.kernel.line("", result.length)
end function

iwlist = mytool.command("iwlist", [], @iwlist_func)
iwlist.short_description = "List all available networks"
iwlist.long_description = "$P;Usage:
$S;system iwlist"



// Kill

kill_args = [
    Arg.New("process", "string").Info("Process to kill. Either name or PID"),
    Kwarg.New("yes", "bool").Alias("y").Info("Don't ask, just terminate")
]

kill_func = function(a)
    if a.kernel.session.computer == null then return ObjectError.New("system.kill", "computer")
    comp = a.kernel.session.computer
    raw_procs = comp.show_procs

    protected = [
        "dsession",
        "Xorg",
        "Kernel_task",
    ]

    procs = []
    tab_data = []
    for x in raw_procs.split(char(10))[1:]
        data = x.split(" ")
        usr = data[0].replace("^root$", a.kernel.color("$root;root$T2;"))
        pid = data[1]
        cpu = data[2]
        mem = data[3]
        cmd = data[4]

        if a.process == "*" or pid == a.process or cmd.indexOf(a.process) != null then
            if protected.indexOf(cmd) != null then 
                print("$error;Skipping protected process " + cmd)
                continue
            end if
            tab_data.push([usr, pid, cpu, mem, cmd])
            procs.push(pid)
        end if
    end for
    result = tabulate_data(tab_data, ["User", "PID", "CPU", "MEM", "Program"], a.kernel.color(["$P;", "$S;", "$T2;", "$T2;", "$S;"]))
    if procs.len == 0 then 
        print("$T;No processes found to kill")
        return
    end if

    a.kernel.line("Processes",result.length)
    print(result.string)
    a.kernel.line("", result.length)

    uinp = ":3"
    while ["y", "n", "yes", "no"].indexOf(uinp.lower()) == null and not a.yes
        uinp = user_input(a.kernel.color("$P;Kill $S;<b>" + procs.len + "</b> $P;processes? $T;(y/n)$T2; :$input; "))
    end while
    if ["n", "no"].indexOf(uinp.lower()) != null then return

    for proc in procs
        result = comp.close_program(to_int(proc))
        if is_error(result) then
            print(result.message)
        else
            print("$P;Killed process $S;<b>" + proc)
        end if
    end for
end function

kill = mytool.standalone_command("kill", kill_args, @kill_func)
kill.short_description = "Kill processes on the system"
kill.long_description  = "$P;Usage:
$S;kill $string;FileExplorer
$S;kill $string;3361"



// ifconfig
ifconfig_args = [
Kwarg.New("connect","string").Alias("c").Info("Wifi essid / gateway")
]
ifconfig_func = function(a)
    findNetFromEssid = function(networks,essid) //@returns {map<string,any>|error}
    for net in networks
        sp = net.split(" ")
        b = sp[0]
        p = sp[1]
        e = sp[2]
        a = 300000/p[:-1].to_int+5
        if e == essid then
            return {"essid":e,"bssid":b,"pwr":p,"acks":a}
        end if
    end for
    return OsError.New("system.ifconfig","Essid not found")
    end function
    comp = a.kernel.session.computer
    router = a.kernel.session.router
    public = "Unknown"

    if not comp then return ObjectError.New("system.ifconfig", "computer")
    if a.connect then
        if is_valid_ip(a.connect) then
            locip = user_input(a.kernel.color("$P;Enter preferred Local Ip: "))
            result = comp.connect_ethernet("eth0",locip,a.connect)
            if is_error(result) then return result.stack("system.ifconfig")
        else
            target = a.connect
            //if target.matches("^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}").len == 0 then return FormatError.New("system.ifconfig","bssid","string")
            nets = comp.wifi_networks("wlan0")
            if is_error(nets) then return nets.stack("system.ifconfig")
            net = findNetFromEssid(nets,target)
            if is_error(net) then return net.stack("system.ifconfig")
            pass = user_input(a.kernel.color("$P;Enter the password for network "+net.essid+"("+net.bssid+")"+": "))
            result = comp.connect_wifi("wlan0",net.bssid,net.essid,pass)
            if is_error(result) then return result.stack("system.ifconfig")
            print("$P;connected to network "+net.essid+"("+net.bssid+") successfully")
        end if
        return
    end if
    if not comp.is_network_active then 
        print("$T;No active network.")
        return
    end if
    if not router then 
        public = comp.public_ip
    else
        public = router.public_ip
    end if

    local = comp.local_ip
    gateway = comp.network_gateway

    print("$S;Public  $T;: $P; " + public)
    print("$S;Local   $T;: $P; " + local)
    print("$S;Gateway $T;: $P; " + gateway)
    print("$T;Connected via: $S;" + comp.active_net_card)
end function

ifconfig = mytool.standalone_command("ifconfig", ifconfig_args, @ifconfig_func)
ifconfig.short_description = "Show network information"
ifconfig.long_description = "$P;Usage:
$S;ifconfig
$S;ifconfig $string;--connect MyWifiNetwork
$S;ifconfig $string;--connect 192.168.0.1"



// reload commands

reload_func = function(a)
    a.kernel.load_tools()
end function



// run

run_args = [
    Arg.New("program", "string").Info("What program to execute"),
    RestArg.New()
]

run_func = function(a)
    if a.kernel.session.shell == null then return ObjectError.New("system.run", "shell")
    args = a.rest
    file = a.kernel.session.file.get_file(a.program)

    if is_error(file) then return file.stack("system.run")
    // if not file.has_permission("x") then return PermissionError.New("system.run", "execute")

    result = a.kernel.session.shell.launch(file.path, args.join(" "))
    log(str(result))

end function


run = mytool.command("run", run_args, @run_func)
run.short_description = "Run baseline shell command"
run.long_description = "$P;Usage:
$S;system run /bin/ls"



// debug

debug_func = function(a)
    a.kernel.DEBUG = not a.kernel.DEBUG
    print("$P;Toggled debug $S;" + ["Off", "On"][a.kernel.DEBUG])
end function

debug = mytool.command("debug", [], @debug_func)
debug.short_description = "Toggle debug on / off"
debug.long_description = "Toggle debug on / off"



// ftp

ftp_args = [
    Arg.New("host", "ip").Info("Host to connect to"),
    Kwarg.New("username", "string").Alias("u").Info("User to login with"),
    Kwarg.New("password", "string").Alias("p").Info("Password to login with"),
    Kwarg.New("port", "int").Alias("p").Default(21).Info("Port to connect to"),
    Kwarg.New("stay", "bool").Alias("s").Info("Stay in current session")
]

ftp_func = function(a)
    if a.kernel.session.shell == null then return ObjectError.New("system.ftp", "shell")
    user = a.username
    pass = a.password

    if user == null then
        user = user_input("<#888>Username: <#fff>")
    end if
    if pass == null then
        pass = user_input("<#888>Password: <size=0.1px>")
    end if

    result = a.kernel.session.shell.connect_service(a.host, a.port, user, pass, "ftp")
    if is_error(result) then return result.stack("system.ftp")
    ses = Session.New(result)
    a.kernel.new_session(ses)

    print("$P;New session created")
    print("$S;"+ ses.user +"$T;@$S;"+ ses.comp_name)
    print("$T;ID:$P;"+ses.id)

    if not a.stay then
        a.kernel.use_session(ses)
        a.kernel.run_command("session", false)
    end if
end function

ftp = mytool.command("ftp", ftp_args, @ftp_func)
ftp.short_description = "Connect to an ftp port and get a shell :3"
ftp.long_description = "$P;Usage
$P;system ftp $string;192.168.1.12
$P;system ftp $string;192.168.1.12 $int;-p 21
$P;system ftp $string;192.168.1.12 $int;-p 21 $string;-u root -p password
$P;system ftp $string;192.168.1.12 $int;-p 32 $string;--username root --password password"



// ssh

ssh_args = [
    Arg.New("host", "string").Info("Host to connect to"),
    Kwarg.New("username", "string").Alias("u").Info("User to login with"),
    Kwarg.New("password", "string").Alias("p").Info("Password to login with"),
    Kwarg.New("port", "int").Default(22).Info("Port to connect to"),
    Kwarg.New("stay", "bool").Alias("s").Info("Stay in current session")
]

ssh_func = function(a)
    if a.kernel.session.shell == null then return ObjectError.New("system.ftp", "shell")
    host = a.host.split("@")
    username = a.username
    password = a.password

    if len(host) != 2 and len(host) != 1 then
        return ValueError.New("system.ssh", "user@ip | ip", a.host)
    end if
    if len(host) == 2 then
        if not is_valid_ip(host[1]) then return ValueError.New("system.ssh", "ip", host[1])
        username = host[0]
        host = host[1]
    end if
    if password == null then
        password = user_input("<#888>Password: <size=0.1px>")
    end if
    if a.username != null then
        host = a.host
    end if

    log(host)
    log(username)
    log(password)
    result = a.kernel.session.shell.connect_service(host, a.port, username, password, "ssh")
    if is_error(result) then return result.stack("system.ssh")
    ses = Session.New(result)
    a.kernel.new_session(ses)

    print("$P;New session created")
    print("$S;"+ ses.user +"$T;@$S;"+ ses.comp_name)
    print("$T;ID:$P;"+ses.id)
    if not a.stay then
        a.kernel.use_session(ses)
        a.kernel.run_command("session", false)
    end if
end function

ssh = mytool.command("ssh", ssh_args, @ssh_func)
ssh.short_description = "Connect to an ssh port and get a shell :3"
ssh.long_description = "$P;Usage
$P;system ssh $string;root@192.168.1.1
$P;system ssh $string;192.168.1.1 -u root -p password"



// su

su_args = [
    Arg.New("user", "string").Info("Username to login as"),
    OptionalArg.New("password", "string").Info("Password to try to login as"),
    Kwarg.New("session", "bool").Alias("s").Default(0).Info("To create a new session from the login")
]

su_func = function(a)
    if a.kernel.session != a.kernel.active_session then return OsError.New("system.su", "Cannot escelate on a non-active system")
    if a.password == null then
        a.password = user_input(a.kernel.color("$T2;Password $T;: <size=0.1px>"))
    end if
    if a.user == "" or a.password == "" then
        err = IdiotError.New("system.su", "User and/or password cannot be empty")
        err.message = err.message.replace("<#0ff>","")
        if rnd * 100 < 1 then err.message = rainbowify(unformat_string(err.message))
        return err
    end if
    shell = get_shell(a.user, a.password)
    if shell == null then return OsError.New("system.su", "Failed to login as " + a.user)
    //if a.user == "" then a.user = a.kernel.session.user
    ses = Session.New(Shell.New(shell), a.user)
    if is_error(ses) then return ses.stack("system.su")

    if ses.computer.is_network_active then
        ses.router = get_router
    end if

    if a.session then
        a.kernel.new_session(ses)
        a.kernel.run_command("session use " + ses.id, false)
    else
        a.kernel.session.overwrite(ses)
        a.kernel.run_command("session", false)
    end if
end function

su = mytool.standalone_command("su", su_args, @su_func)
su.short_description = "Login as another user"
su.long_description = "$P;Usage:
$P;su $string;root ""password""
$P;su $string;some_user"



// download

download_args = [
    Arg.New("file", "string").Info("File to download from session"),
    OptionalArg.New("folder", "string").Info("Folder to download to (Full path)"),
    Kwarg.New("from", "int").Alias("f").Info("Session to download from (Defaults to active session)"),
    Kwarg.New("name", "string").Alias("n").Info("New name of file after download")
]

download_func = function(a)
    if a.kernel.session.shell == null then return ObjectError.New("system.download", "shell")
    if a.name != null and not isalnum(a.name) then return FormatError.New("system.download", "numbers , letters , -_.", a.name)

    active_session = a.kernel.active_session
    current = a.kernel.session

    if a["from"] != null then
        active_session = null
        for x in a.kernel.sessions
            if x.id == a["from"] then
                active_session = x
            end if
        end for
    end if

    target = current.file.path
    if a.folder != null then target = a.folder
    target_file = current.computer.File(target)
    if is_error(target_file) then return target_file.stack("system.download")
    if not target_file.is_folder then return OsError.New("system.download", "Download path is not a folder $T;" + target)
    
    if active_session == a.kernel.session then return OsError.New("system.download", "Cannot download from same session")
    if active_session == null then return OsError.New("system.download", "Session with id '"+a["from"]+"' not found")
    if not target_file.has_permission("w") then OsError.New("system.download", "Download folder needs write access $T;" + target)

    file = active_session.file.get_path(a.file)
    if is_error(file) then return file.stack("system.download")
    if not file.has_permission("r") then return OsError.New("system.download", "File needs read access")

    file_overwrite = false
    if file.has_permission("r") and file.is_file then file_overwrite = true

    if current.shell == null and not file_overwrite then return OsError.New("system.download", "Current session needs shell access")
    if not file.has_permission("r") and not file_overwrite then return OsError.New("system.download", "Download file needs read access")

    log(file.path)
    log(a.kernel.session.file.path)

    if a.name != null and a.name != file.name and not file_overwrite then
        // Create temp dir
        err = current.computer.create_folder(target_file.path, "CS_TMP")
        if is_error(err) then return err.stack("system.download")

        tmp_folder = current.computer.File(target_file.path+"/CS_TMP")
        if is_error(tmp_folder) then return tmp_folder.stack("system.download")

        // Upload file
        res = active_session.shell.scp(file.path, target_file.path + "/CS_TMP", a.kernel.session.shell)
        if is_error(res) then 
            tmp_folder.move(tmp_folder.path, tmp_folder.name)
            return res.stack("system.download")
        end if
        tmp_file = current.computer.File(tmp_folder.path + "/" + file.name)
        
        // Rename & move to target folder and delete temp folder
        err = tmp_file.move(target_file.path, a.name)
        err2 = tmp_folder.move(tmp_folder.path, tmp_folder.name)
        if is_error(err) then return err.stack("system.download")
        if is_error(err2) then return err2.stack("system.download")

    else if file_overwrite then
        new_name = file.name
        if a.name != null and a.name != file.name then new_name = a.name
        session.computer.touch(target_file.path, new_name)
        f = session.file.get_file(target_file.path + "/" + new_name)
        if is_error(f) then return f.stack("system.upload")
        f.set_content(file.get_content)

    else
        res = active_session.shell.scp(file.path, target_file.path, a.kernel.session.shell)
    end if
end function

download = mytool.standalone_command("download", download_args, @download_func)
download.short_description = "Download from the active (or another) session to the current session"
download.long_description = "$P;Usage:
$P;download $string;/root/safelib/init.so $int;-f 1 $T;<< Download from session 1 to current session
$P;download $string;/scripts/virus $int;-f 1 $string;/bin $T;<< Download from session 1, and upload to /bin in current session"



// upload

upload_args = [
    Arg.New("file", "string").Info("File to upload to session"),
    OptionalArg.New("folder", "string").Info("Folder to upload to (Full path)"),
    Kwarg.New("to", "int").Alias("t").Info("Session to upload to (Defaults to active session)"),
    Kwarg.New("name", "string").Alias("n").Info("New name of file after download")
]

upload_func = function(a)
    // if a.kernel.session.shell == null then return ObjectError.New("system.upload", "shell")

    session = a.kernel.active_session
    target = session.file.path
    if a.to != null then
        session = null
        for x in a.kernel.sessions
            if x.id == a.to then
                session = x
            end if
        end for
    end if

    if a.folder != null then target = a.folder
    
    if session == a.kernel.session then return OsError.New("system.upload", "Cannot upload to same session")
    if session == null then return OsError.New("system.upload", "Session with id '"+a.to+"' not found")
    if not session.file.has_permission("w") then OsError.New("system.upload", "Target session path needs write access")
    file = a.kernel.session.file.get_path(a.file)
    if is_error(file) then return file.stack("system.upload")
    
    file_overwrite = false
    if file.has_permission("r") and file.is_file then file_overwrite = true

    if session.shell == null and not file_overwrite then return OsError.New("system.upload", "Target session needs shell access")
    if not file.has_permission("r") and not file_overwrite then return OsError.New("system.upload", "File needs read access")

    if not file_overwrite then
        res = a.kernel.session.shell.scp(file.path, session.file.path, session.shell)
        if is_error(res) then return res.stack("system.upload")
    else
        session.computer.touch(session.file.path, file.name)
        f = session.file.get_file(session.file.path + "/" + file.name)
        if is_error(f) then return f.stack("system.upload")
        f.set_content(file.get_content)
    end if
end function

upload = mytool.standalone_command("upload", upload_args, @upload_func)
upload.short_description = "Upload a file from the current session to the active (or another) session"
upload.long_description = "$P;Usage:
$P;upload $string;/var/virus $int;--to 2
$P;upload $string;/user/Jessa/traffic_network
$P;upload $string;/user/Jessa/traffic_network /root/network_log $int;--to 1
$P;upload $string;/root/test $int;--to 2 $string;--name new_test $T;<< Upload from current session, to session 2, and rename file to new_test"



// ping

ping_args = [
    Arg.New("host", "ip").Info("Host to ping")
]

ping_func = function(a)
    host = a.host.trim
    if not is_valid_ip(host) then
        // matches (https://)(www.)host.tld
        if not host.is_match("^(https:\/\/)?(w{3}\.)?\w+\.(com|org|net|info)$") then return ValueError.New("system.ping", "ip/host", host)
        host = nslookup(host)
        if host == "IP not found" then return OsError.New("system.ping", "Host address not found")
    end if

    shell = a.kernel.session.shell
    if not is_lan_ip(host) then
        shell = a.kernel.sessions[0].shell
    end if

    if shell == null then return ObjectError.New("system.ping", "shell")

    result = shell.ping(host)
    msg = "$P;Host $S;" + host + " $P;is "
    if is_error(result) then return result.stack("system.ping")
    if result then
        msg = msg + "$S;Reachable"
    else
        msg = msg + "$error;Not reachable"
    end if
    print(msg)
end function

ping_cmd = mytool.standalone_command("ping", ping_args, @ping_func)
ping_cmd.short_description = "Ping host to see if it's reachable"
ping_cmd.long_description = "$P;Usage:
$P;ping $string;192.168.0.1
$P;ping $string;134.122.3.12
$P;ping $string;mybank.org
$P;ping $string;www.mybank.org"



// build

build_args = [
    Arg.New("source", "string").Info("Source file to build"),
    Kwarg.New("allow-import", "bool").Alias("a").Default(false).Info("Allow final binary to be imported")
]

build_func = function(a)
    if a.kernel.session.shell == null then return ObjectError.New("system.build", "shell")
    file = a.kernel.session.file.get_file(a.source)
    if is_error(file) then return file.stack("system.build")

    dest = a.kernel.session.file.path

    log(a["allow-import"])
    res = a.kernel.session.shell.build(file.path, dest, a["allow-import"])
    if is_error(res) then return res.stack("system.build")
    print("$S;Successfully build binary")
end function

build_cmd = mytool.command("build", build_args, @build_func)
build_cmd.short_description = "Build code files into binaries"
build_cmd.long_description = "$P;Usage:
$P;system build $lscode;/root/myprogram.src
$P;system build $lscode;/root/myprogram.src $bool;--allow-import"



// groupadd

groupadd_args = [
    Arg.New("user", "string").Info("Which user to add to the group"),
    Arg.New("group", "string").Info("Group name to add to the user")
]

groupadd_func = function(a)
    ses = a.kernel.session
    if ses.computer == null then return ObjectError.New("system.groupadd", "computer")
    if not ses.user == "root" then return PermissionError.New("system.groupadd", "root")

    res = ses.computer.create_group(a.user, a.group)
    if is_error(res) then return res.stack("system.groupadd")
    print("$S;Added $T2;" + a.user + " $S;to group $T2;" + a.group)
end function

groupadd = mytool.command("groupadd", groupadd_args, @groupadd_func)
groupadd.short_description = "Add groups to users"
groupadd.long_description = "$P;Usage:
$P;system addgroup $string;root coolgroup
$P;system addgroup $string;jessa crows"



// groupdel

groupdel_args = [
    Arg.New("user", "string").Info("Which user to add to the group"),
    Arg.New("group", "string").Info("Group name to add to the user")
]

groupdel_func = function(a)
    ses = a.kernel.session
    if ses.computer == null then return ObjectError.New("system.groupdel", "computer")
    if not ses.user == "root" then return PermissionError.New("system.groupdel", "root")

    res = ses.computer.delete_group(a.user, a.group)
    if is_error(res) then return error.stack("system.groupdel")
    print("$S;Removed $T2;" + a.user + " $S;from the group $T2;" + a.group)
end function

groupdel = mytool.command("groupdel", groupdel_args, @groupdel_func)
groupdel.short_description = "Remove users from a group"
groupdel.long_description = "$P;Usage:
$P;system groupdel $string;root coolgroup
$P;system groupdel $string;jessa crows"



// userdel

userdel_args = [
    Arg.New("user", "string").Info("Which user to delete from existance"),
    Kwarg.New("home", "bool").Default(false).Alias("h").Info("Delete their home directory as well")
]

userdel_func = function(a)
    ses = a.kernel.session
    if ses.computer == null then return ObjectError.New("system.userdel", "computer")
    if not ses.user == "root" then return PermissionError.New("system.userdel", "root")

    res = ses.computer.delete_user(a.user, a.home)
    if is_error(res) then return res.stack("system.userdel")
    log(res)
    print("$S;Successfully deleted user $T2;" + a.user)
end function

userdel = mytool.command("userdel", userdel_args, @userdel_func)
userdel.short_description = "Delete a user from the system"
userdel.long_description = "$P;Usage:
$P;system userdel $string;jess $bool;--home
$P;system userdel $string;jess"



// useradd

useradd_args = [
    Arg.New("username", "string").Info("Username of the new user"),
    Arg.New("password", "string").Info("Password for the new user")
]

useradd_func = function(a)
    ses = a.kernel.session
    if ses.computer == null then return ObjectError.New("system.useradd", "computer")
    if not ses.user == "root" then return PermissionError.New("system.useradd", "root")

    res = ses.computer.create_user(a.username, a.password)
    if is_error(res) then return res.stack("system.useradd")
    log(res)
    print("$S;Successfully created user $T2;" + a.username + "$S; with password $T2;" + a.password)
end function

useradd = mytool.command("useradd", useradd_args, @useradd_func)
useradd.short_description = "Create a new user in the system"
useradd.long_description  = "$P;Usage:
$P;system useradd $string;jess crowpassword" 


// whois

whois_args = [
    Arg.New("host", "ip")
]

whois_func = function(a)
    if a.host == "" then return OsError.New("system.whois", "Host cannot be empty")

    res = whois(a.host)
    if res.indexOf(char(10)) == null then return Error.New("system.whois", res)
    parts = res.replace(char(10), ":").split(":")
    log(parts)

    domain = parts[1]
    admin = parts[3]
    email = parts[5]
    phone = parts[7]

    print("$T2;Domain $T;:$P;" + domain)
    print("$T2;Admin  $T;:$P;" + admin)
    print("$T2;E-Mail $T;:$P;" + email)
    print("$T2;Phone  $T;:$P;" + phone)
    if res.is_match("Neurobox") then
        print("$T;Neurobox system")
    end if
end function

whois_cmd = mytool.standalone_command("whois", whois_args, @whois_func)
whois_cmd.short_description = "Show admin info for ip"
whois_cmd.long_description = "$P;Usage:
$P;whois $ip;12.34.56.78"



// remlog

remlog_args = [
    Kwarg.New("message", "string").Alias("m").Info("Content to add to the log (to leave behind message)")
]

remlog_func = function(a)
    ses = a.kernel.session
    log_file = ses.file.get_file("/var/system.log")
    if is_error(log_file) then return log_file.stack("system.remlog")
    if not log_file.has_permission("rw") then return PermissionError.New("system.remlog", "Read & Write for /var/system.log")

    if ses.computer != null then
        if ses.computer == null then return ObjectError.New("system.remlog", "computer")
        attempt = ses.computer.touch("/var", "owo.txt", a.message)
        if is_error(attempt) then return attempt.stack("system.remlog")
        wait(0.02)
        file = ses.file.get_file("/var/owo.txt")
        if is_error(file) then return file.stack("system.remlog")
        res = file.move("/var", "system.log")
        if is_error(res) then return res.stack("system.remlog")
        print("$S;Successfully corrupted log")
        return
    end if

    file = null
    for f in ses.file.get_folder("/").find_permission("w", true, false)
        if f.is_file() then
            if f.path == "/etc/xorg.conf" then continue
            file = f
            if f.path == "/etc/fstab" then break
            if f.path == "/etc/init.d/Sources.txt" then break
        end if
    end for

    if file == null then return OsError.New("system.remlog","No files found to overwrite system.log")

    if a.message != null then file.set_content(a.message)
    res = file.move("/var", "system.log")
    if is_error(res) then return res.stack("system.remlog")

    print("$S;Successfully corrupted log")
end function

remlog = mytool.command("remlog", remlog_args, @remlog_func)
remlog.short_description = "Corrupt the log"
remlog.long_description = "$P;Usage:
$P;system remlog"

// symlink

symlink_args = [
    Arg.New("path", "string").Info("File to create a link for"),
    Arg.New("target", "string").Info("Destination to create link to")
]

symlink_func = function(a)
    ses = a.kernel.session.file

    target = ses.get_path(a.path)
    if is_error(target) then return target.stack("system.symlink")

    p = Path.New(ses.path)
    p.change(a.target)

    target_folder = null
    filename = null

    temp = ses.get_path(p.path)
    if is_error(temp) then
        filename = p.name
        target_folder = p.folder
    else if temp.is_folder then
        filename = target.name
        target_folder = p.path
    else
        return OsError.New("system.symlink", "File already exists : " + p.path)
    end if
    log(target_folder)
    log(filename)
    log(p.path)
    res = target.symlink(target_folder, filename)
    if is_error(res) then return res.stack("system.symlink")
    print("$P;Created symlink $lssymlink;" + target_folder +"/"+filename)
end function

symlink_cmd = mytool.command("ln", symlink_args, @symlink_func)
symlink_cmd.short_description = "Create symbolic link of a file"
symlink_cmd.long_description = "$P;Usage:
$P;ln $string;/home/jess/program /bin/program
$P;ln $string;/home/jess /root/jess"


// rf

reformat_args = [
    Arg.New("seperator", "string").Info("Seperator to use to format output with"),
    Arg.New("format", "string").Info("Format to use for data"),
    Kwarg.New("trim", "bool").Alias("t").Info("Trim leading/trailing whitespaces"),
    Kwarg.New("raw", "bool").Alias("r").Info("Parse result with command rather than string parameter"),
    RestArg.New()//.Info("Data (Will be joined with a singular space)")
]

reformat_func = function(a)
    if len(a.rest) == 0 then return Error.New("system.reformat", "No data supplied")
    raw_data = a.rest.join(" ")
    data = []
    log(a.rest)

    for x in raw_data.split(a.seperator)
        if x == "" then continue
        if a.trim then
            data.push(x.trim)
        else
            data.push(x)
        end if
    end for

    result = a.format

    for i in data
        result = result.replace("\{"+__i_idx+"\}", i)
    end for

    if a.raw then
        a.kernel.raw_piped = true
    end if
    print(result)
end function

reformat = mytool.standalone_command("rf", reformat_args, @reformat_func)
reformat.short_description = "Reformat input data to be used as you wish"
reformat.long_description = "$P;Usage:
$T2;echo 'test:1:2:3' | $P;rf $string;':' '{0} {1} {2} {3}' $T;>> 'test 1 2 3'
$T2;crack 'root:4337fb150cbc24bd1842fb3b8f828a6c' | $P;rf $string;':' '-u ""{0}"" -p ""{1}""' --raw | system ssh 1.2.3.4"

// write

write_args = [
    Arg.New("target", "string").Info("Target file to write to"),
    RestArg.New().Info("String to write to file"),
]

write_function = function(a)
    file = a.kernel.session.file.get_file(a.target)
    if is_error(file) then return file.stack("system.write")
    if not file.is_file then return OsError.New("system.write", "Cannot write to non-file")
    if not file.has_permission("r") then return PermissionError.New("system.write", "Read / Write")
    if not file.parent.has_permission("w") then return PermissionError.New("system.write", "Read / Write")

    content = file.get_content()

    log(a.rest)
    if a.rest == null then a.rest = []
    input_content = a.rest.join(" ")
    if input_content[-1] != char(10) then
        input_content = input_content + char(10)
    end if

    new_content = content + input_content

    file.set_content(new_content)
end function

write_cmd = mytool.command("write", write_args, @write_function)

// install

install_args = [
    Arg.New("service", "string").Info("Service library to install"),
    Kwarg.New("start", "bool").Info("Start the service after install"),
    Kwarg.New("stop", "bool").Info("Stop the service"),
]

install_func = function(a)
    if a.kernel.session.user != "root" then return PermissionError.New("system.install", "root")
    if a.kernel.active_session != a.kernel.session then return 

    file = a.kernel.session.file.get_file(a.service)
    if is_error(file) then return file.stack("system.install")
    log("$T2;active user: $S;"+ active_user)
    lib = include_lib(file.path)
    if lib == null then return OsError.New("system.install", "Library " + a.service + " not found")

    if a.stop then
        res = lib.stop_service()
        if res isa string then return Error.New("system.install", res)
        return
    end if

    res = lib.install_service()
    if res isa string then return Error.New("system.install", res)

    if a.start then
        wait(0.1)
        res = lib.start_service()
        if res isa string then return Error.New("system.install", res)
    end if
end function

install_cmd = mytool.command("install", install_args, @install_func)
install_cmd.short_description = "Install, start or stop a service"
install_cmd.long_description =  "$P;Usage:

$P;install /lib/libssh.so
$P;install /lib/libssh.so --start
$P;install /lib/libssh.so --stop"


// terminal

terminal_args = []

terminal_func = function(a)
    if a.kernel.session.shell == null then return ObjectError.New("system.terminal", "shell")

    confirm = confirmation_prompt("<#f00><b>This will quit crowsploit, and thus will lose all of your sesssions. Continue?")
    if not confirm then return

    a.kernel.keep_session = false
    a.kernel.session.shell.start_terminal()
end function

terminal_cmd = mytool.command("terminal", [], @terminal_func)
terminal_cmd.short_description = "Start active terminal"
terminal_cmd.long_description = "$P;Usage:
system terminal"

// Passwd

passwd_args = [
    Arg.New("user", "string").Info("User to change password for"),
    OptionalArg.New("password","string").Info("New password for user")
]

passwd_func = function(a)
    if a.kernel.session.user != "root" then return PermissionError.New("system.passwd", "root")

    if a.password == null then
        a.password = user_input("Password : <size=0.1px>")
    end if

    res = a.kernel.session.computer.change_password(a.user, a.password)
    if is_error(res) then return res.stack("system.passwd")
    print("$S;Succesfully changed password")
end function

passwd_cmd = mytool.command("passwd", passwd_args, @passwd_func)
passwd_cmd.short_description = "Change password for existing user"
passwd_cmd.long_description = "$P;Usage:
$P;system passwd $string;root mypass
$P;system passwd $string;Jessa"


// wait

wait_args = [
    Arg.New("amount","float").Info("Amount of time to wait (in seconds)")
]

wait_func = function(a)
    if a.amount < 0.01 then
        return OsError.New("system.wait", "Cannot wait less than 0.01 seconds due to greyscript limitations")
    end if

    count = floor(a.amount / 300)
    if count > 0 then
        for x in range(count)
            wait(300)
        end for
    end if

    if a.amount%300 != 0 then
        wait(a.amount%300)
    end if
end function

wait_cmd = mytool.command("wait", wait_args, @wait_func)
wait_cmd.short_description = "Wait x amount of time before running next command"
wait_cmd.long_description = "$P;Usage
system wait $float; 3
$P;system wait $float 0.2"


// rename

rename_args = [
    Arg.New("file", "string").Info("File to rename"),
    Arg.New("name", "string").Info("New name for file")
]

rename_func = function(a)
    file = a.kernel.session.file.get_path(a.file)
    if is_error(file) then return file.stack("system.rename")
    if not file.has_permission("w") then return PermissionError.New("system.raname", "read")
    result = file.rename(a.name)
    if is_error(result) then return result.stack("system.rename")
end function

rename_cmd = mytool.command("rename", rename_args, @rename_func)
rename_cmd.short_description = "Rename a file or folder"
rename_cmd.long_description  = "$P;Usage:
$P;system rename $string;/etc/passwd passnt
$P;system rename $string;/var/system.log lognt"

// passgen

passgen_args = [
    OptionalArg.New("format", "string").Default("aA0").Info("What format to generate passwords too"),
    Kwarg.New("length", "int").Alias("l").Default(15).Info("Length of password to generate")
]

passgen_func = function(a)
    formats = {
        "a": "abcdefghijklmnopqrstuvwxyz",
        "A": "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        "0": "0123456789"
    }

    choice = ""
    for x in a.format 
        if not formats.hasIndex(x) then return FormatError.New("system.passgen", "a | A | 0", a.format)
        choice = choice + formats[x]
    end for

    if len(choice) == 0 then return Error.New("system.passgen", "Format cannot be empty")

    result = ""
    for x in range(a.length-1)
        result = result + choice[floor(rnd()*len(choice))]
    end for
    print("$S;" + result)
end function

passgen_cmd = mytool.command("passgen", passgen_args, @passgen_func)
passgen_cmd.short_description = "Generate a password"
passgen_cmd.long_description  = "$P;Formats:
$S;a $T;: $string;abcdefghijklmnopqrstuvwxyz
$S;A $T;: $string;ABCDEFGHIJKLMNOPQRSTUVWXYZ
$S;0 $T;: $string;0123456789

$P;Usage:
$P;passgen -l 5 $T;> ab3D0
$P;passgen a 10 $T;> fbqorfhaix
$P;passgen 0 10 $T;> 7781945292"

// update

update_func = function(a)
    r = a.kernel.check_update()
    if is_error(r) then return r.stack("system.update")
end function
update_cmd = mytool.command("update", [], @update_func)
update_cmd.short_description = "Check if there are available updates"
update_cmd.long_description  = "Check if there are available updates"

// concat

concat_args = [
    RestArg.New().Info("Strings to join together"),
    Kwarg.New("delimiter", "string").Default("").Alias("d").Info("Character to join the strings together"),
    Kwarg.New("inverted", "bool").Alias("i").Info("Join them togehter in a reversed order"),
    Kwarg.New("raw", "bool").Alias("r").Info("Parse result with command rather than string parameter")
]

concat_func = function(a)
    if a.inverted then a.rest.reverse
    if a.raw then a.kernel.raw_piped = true
    print(a.rest.join(a.delimiter))
end function

concat_cmd = mytool.standalone_command("concat", concat_args, @concat_func)
concat_cmd.short_description = "Combine strings together"
concat_cmd.long_description  = "$P;Usage:
$P;concat $string;'hello' 'how' 'are' 'you' $T;>> 'hellohowareyou'
$P;concat $string;--delimter ':' $WAN 21 $T>> '32.12.53.2:21'
$P;concat $string;--delimter '@' $USER wuwuvik.com $T>> 'user@wuwuvik.com'"

// file

finf_args = [
    OptionalArg.New("file","string").Info("Target file path")
]

finf_func = function(a)
    sess_file = a.kernel.session.file
    if a.file == null then a.file = "."
    file = sess_file.get_path(a.file)

    if is_error(file) then return file.stack("system.file")
    user = a.kernel.session.user 
    if user == "unknown" then user = null
    file_info = [["name:", file.name], ["path: ", file.path], ["size:", round(to_int(file.size)/1048576, 2) + "MB"], ["owner:", file.owner], ["group:", file.group], ["perms:", file.permissions], ["effective:", file.get_effective_permissions(true,false,user)]]
    if file.is_folder then file_info.push(["subitems: ", (file.get_files + file.get_folders).len])
    is_sym = file.is_symlink
    type = file.file_type

    if is_sym then
        temp_file = file.get_path(file.path(true))
        type = "[Deleted]"
        if not is_error(temp_file) then type = temp_file.file_type
    end if

    file_info.push(["type:", type])
    file_info.push(["symlink:", ["no","yes"][is_sym]])

    if is_sym then file_info.push(["target:", file.path(true)])

    print(tabulate_data(file_info,["",""], a.kernel.color(["$T;", "$S;"])).string.split(char(10))[1:].join(char(10)))
end function

finf_cmd = mytool.standalone_command("finf", finf_args, @finf_func)
finf_cmd.short_description = "View detailed file information"
finf_cmd.long_description = "$P;Usage:
$P;system $S;finf $string;testfolder$P; >>
$P;name: $string;testfolder         
$P;path: $string;/root/test/testfolder          
$P;size: $string;1.2MB   
$P;owner: $string;root        
$P;group: $string;root        
$P;perms: $string;-rwxr-xr-x
$P;effective: $string;read, write(Full), execute
$P;type: $string;folder      
$P;subitems: $string;2          
$P;symlink: $string;yes
$P;target: $string;/root/target"




// monitor 
// sysmon
sysmon_args = [
    Kwarg.New("delay", "float").Default(0.25).Info("How long between checks"),
]

// Probably the ugliest command in cs, but we'll keep it ;3
sysmon_func = function(a)
    if a.delay < 0.1 then return ParseError.New("system.monitor", "Delay can not be less than 0.1")
    if a.delay > 300 then return ParseError.New("system.monitor", "Delay can not be greater than 300")
    // c = confirmation_prompt("$error;WARNING; ONCE STARTED, YOU CAN NOT STOP THE SYSTEM MONITOR"+char(10)+"$P;Continue?")
    // if not c then return

    colors = {
        "file" : "<#aaa>",
        "folder" : "<#08f>",
        "binary" : "<#0e8>",
        "symlink" : "<#c158d6>",
        "new" : "<#0f4>",
        "missing" : "<#f04>",
        "changed" : "<#fa0>",
        "normal" : "<#aaa>",
        "misc" : "<#08f>",
    }

    get_type = function(file_ob)
        if file_ob.is_folder then
            return "folder"
        else if file_ob.is_binary then
            return "binary"
        end if
        return "file"
    end function

    true_type = function(ob)
        if ob.is_symlink then
            return "symlink"
        end if
        return get_type(ob)
    end function

    change = function(type, a, b)
        return {
            "type":type,
            "original":a,
            "new":b,
        }
    end function

    F = {}
    F.New = function(a)
        f = new self
        f.group = a.group
        f.permissions = a.permissions
        f.type = get_type(a)
        f.size = a.size
        f.path = a.path
        f.owner = a.owner
        f.content = null
        f.name = a.name
        f.truetype = true_type(a)
        f.color = colors[f.truetype]

        if f.type == "file" and a.has_permission("r") then
            f.content = a.get_content()
        end if

        return f
    end function

    F.is = function(b)
        if b.path != self.path then return false
        if b.type != self.type then return false
        
        return true
    end function

    F.difference = function(b)
        result = []
        a = self

        if b.size != a.size then 
            result.push(change("size", b.size, a.size))
        end if
        if b.name != a.name then 
            result.push(change("name", b.name, a.name))
        end if
        if b.group != a.group then 
            result.push( change("group", b.group, a.group))
        end if
        if b.owner != a.owner then 
            result.push(change("owner", b.owner, a.owner))
        end if
        if a.permissions != b.permissions then
            result.push(change("permissions", b.permissions, a.permissions))
        end if

        if a.content != b.content and a.content != null then
            result.push(change("content", a.content, b.content))
        end if

        return result
    end function

    F.similar = function(b)
        result = 0
        a = self
        if a.type != b.type then return false
        if a.size == b.size then result = result + 1
        if a.name == b.name then result = result + 1
        if a.group == b.group then result = result + 1
        if a.owner == b.owner then result = result + 1
        if a.permissions == b.permissions then result = result + 1
        if a.content == b.content then result = result + 1
        if a.path == b.path then result = result + 1

        return result >= 5
    end function

    get_files = function(folder)
        result = [F.New(folder)]
        for x in folder.get_files
            result.push(F.New(x))
        end for
        for x in folder.get_folders
            result = result + get_files(x)
        end for
        return result
    end function

    list.copy = function()
        result = []
        for x in self
            result.push(x)
        end for
        return result
    end function

    get_procs = function(c)
        procs = c.show_procs.split(char(10))[1:]
        result = []
        for p in procs
            temp = p.split(" ")
            pid = temp[1]
            command = temp[4]
            result.push({"pid":pid, "command":command})
        end for
        return result
    end function

    list.difference_files = function(b)
        new_items = []
        missing_items = []
        changed_items = {}

        found_a = []
        for x in self
            found = false
            for y in b
                if x.is(y) and found_a.indexOf(__y_idx) == null then
                    found_a.push(__y_idx)
                    found = true
                    dif = x.difference(y)
                    if dif != [] then changed_items[x.path] = {"file":x,"change":dif}
                    break
                end if
            end for

            if not found then
                new_items.push(x)
            end if
        end for

        found_b = []
        for x in b
            found = false
            for y in self
                if x.is(y) and found_b.indexOf(__y_idx) == null then
                    found_b.push(__y_idx)
                    found = true
                    dif = y.difference(x)
                    if dif != [] then changed_items[x.path] = {"file":y,"change":dif}
                    break
                end if
            end for

            if not found then
                missing_items.push(x)
            end if
        end for
        return {"new":new_items,"missing":missing_items,"changed":changed_items.values}
    end function

    list.difference = function(b)
        new_items = []
        missing_items = []

        found_a = []
        for x in self
            found = false
            for y in b
                if x == y and found_a.indexOf(__y_idx) == null then
                    found_a.push(__y_idx)
                    found = true
                    break
                end if
            end for

            if not found then
                new_items.push(x)
            end if
        end for

        found_b = []
        for x in b
            found = false
            for y in self
                if x == y and found_b.indexOf(__y_idx) == null then
                    found_b.push(__y_idx)
                    found = true
                    break
                end if
            end for

            if not found then
                missing_items.push(x)
            end if
        end for
        return {"new":new_items,"missing":missing_items}
    end function

    old_files = get_files(comp.File("/"))
    old_processes = get_procs(comp)

    wan = a.kernel.session.wan
    unique = string_gen("symon", 5)
    identifier = "sysmon_"+wan+"_"+unique

    last_date = get_epoch
    delay_min = ceil(a.delay / (4/16)) + 2
    tmp_file = Temp.New(a.kernel, identifier, delay_min + 2, "Monitoring " + wan + " at " + kernel.session.lan)
    if is_error(tmp_file) then return tmp_file.stack("system.monitor")

    print("$P;Monitoring has started"+char(10), true)
    print("<i>$S;<size=80%>(Monitor can be stopped using $T2;loops stop " + identifier + " $S;in another crowsploit instance)")

    while tmp_file.is_alive
        epoch = get_epoch
        if (epoch - last_date)/60 >= delay_min then
            tmp_file.update_ttl(delay_min+2)
            last_date = epoch
        end if

        new_files = get_files(comp.File("/"))
        new_processes = get_procs(comp)

        difference = new_files.difference_files(old_files)

        skip = []
        for x in difference.missing 
            for y in difference["new"]
                if x.similar(y) then
                    skip.push(x)
                    skip.push(y)
                    print(colors.changed + "- " + x.color + x.path + colors.changed + " > " + x.color + y.path)
                    break
                end if
            end for
        end for

        for x in difference.missing
            if skip.indexOf(x) != null then continue
            print(colors.missing + "x " + x.color + x.path)
        end for

        for x in difference["new"]
            if skip.indexOf(x) != null then continue
            print(colors["new"] + "+ " + x.color + x.path)
        end for

        for x in difference.changed
            for y in x.change
                if y.type == "content" then
                    print(colors.changed + "? " + x.file.color + x.file.path + colors.normal + " : " + y.type)
                else
                    print(colors.changed + "? " + x.file.color + x.file.path + colors.normal + " : " + y.type + " : " + colors.misc + y.original + colors.changed + " > " + colors.misc + y["new"])
                end if
            end for
        end for

        difference = new_processes.difference(old_processes)
        for x in difference["new"]
            print(colors["new"] + "> " + colors.normal + x.command + "<#888> @ " + colors.normal + x.pid)
        end for
        for x in difference.missing
            print(colors.missing + "- " + colors.normal + x.command + "<#888> @ " + colors.normal + x.pid)
        end for

        old_files = new_files
        old_processes = new_processes
        wait(a.delay)
    end while
end function

sysmon_cmd = mytool.command("monitor", sysmon_args, @sysmon_func)
sysmon_cmd.small_description = "Monitor system for changes and display to terminal"
sysmon_cmd.long_description = "$P;Usage:
$P;monitor"

// cloak/streamer mode

cloak_args = [
    // Kwarg.New("on", "bool").Alias("e").Info("Enables streamer mode"),
    // Kwarg.New("off", "bool").Alias("d").Info("Disables streamer mode"),
    Kwarg.New("status","bool").Alias("s").Info("Shows the current status of streamer mode")
]

cloak_func = function(a)
    //if a.on and a.off then return ParseError.New("system.cloak", "Cannot enable and disable streamer mode at the same time")

    prev = a.kernel.settings.interface.streamer_mode
    if prev == "true" then prev = 1 else prev = 0

    if not a.status then
        a.kernel.settings.interface.streamer_mode = ["true", "false"][prev]
        if prev == 0 then
            print("$S;Streamer mode enabled")
        else
            print("$S;Streamer mode disabled")
        end if
    end if

    if a.status then
        status = ["$error;Disabled", "$S;Enabled"][prev]
        print("$T2;Streamer mode: $P;" + status)
    end if

end function

cloak_cmd = mytool.standalone_command("cloak", cloak_args, @cloak_func)
cloak_cmd.short_description = "Enable or disable streamer mode"
cloak_cmd.long_description = "$P;Usage:
$P;system cloak
$P;system cloak $bool;--status"


// neofetch

neofetch_args = []
neofetch_func = function(a)
    temp_motd = motd.trim().split(char(10))
    longest = 0
    for x in temp_motd
        tmp = a.kernel.color(rtrim(x))
        temp_motd[__x_idx] = tmp
        length = len(unformat_string(tmp))
        longest = [longest, length][length>longest]
    end for
    
    longest = longest + 4
    colors = a.kernel.color(["$P;", "$S;", "$T;", "$T2;", "$input;", "$root;",
              "$obj_shell;", "$obj_computer;", "$obj_file;",
              "$lsfolder;", "$lsbinary;", "$lsfile;", "$lscode;",
              "$string;", "$int;", "$float;", "$ip;", "$bool;"])
    
    new_colors = []
    for x in colors
        color = x[2:].split("=")[-1][:-1]
        if not color.is_match("^[a-fA-F0-9]+$") then continue
        if len(color) == 3 then color = color[0] + color[0] + color[1] + color[1] + color[2] + color[2]
        new_colors.push("<mark=#" + color + ">--")
    end for
    middle = ceil(len(colors)/2)
    template_colors = ["<size=130%>"+new_colors[:middle].join(""), "<size=130%>"+new_colors[middle:].join("")]

    kernel_version = a.kernel.version
    template = [
        "$P;$USER$T2;@$S;$COMP",
        "$T2;------------------",
        "$P;Kernel    $T2;: $S;" + kernel_version,
        "$P;Interface $T2;: $S;" + interface_version,
        "$P;WAN       $T2;: $S;$WAN",
        "$P;LAN       $T2;: $S;$LAN",
        "$P;Tools     $T2;: $S;" + len(a.kernel.tools),
        " "
    ] + template_colors

    result = []
    count = max(len(temp_motd), len(template))
    motd_offset = ceil((len(template) - len(temp_motd)) / 2)
    // print([count, len(template), len(temp_motd)].join(" | "))
    for x in range(0, count)
        tmp = ""
        if x >= motd_offset and len(temp_motd) > x-motd_offset then tmp = temp_motd[x-motd_offset]
        if len(template) > x then tmp = tmp + " "*(longest-len(unformat_string(tmp))) + template[x]
        result.push(tmp)
    end for
    new_motd = result.join(char(10))

    for x in a.kernel.env
        new_motd = new_motd.replace("\$"+x.key, str(x.value).trim)
    end for
    new_motd = new_motd.replace("root", "$root;root")
    
    print(new_motd)
end function

neofetch_cmd = mytool.command("neofetch", neofetch_args, @neofetch_func)

// init

mytool.init()


import_code("./session")
import_code("./apt-get")
import_code("./alias")
import_code("./repeat")
import_code("./env")
import_code("./macro")
// import_code("./monitor")