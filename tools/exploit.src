import_code("../kernel/toolkernel")
import_code("../libs/utils")
import_code("../libs/metautils")
import_code("../libs/sessionmanager")

mytool = Tool.New("exploit", "1.6.1")

settings = Settings.init()
settings.set("database", {
    "location":"/etc/crow/exdb",
})

mytool.settings = settings


mytool.short_description = "Exploit vulnerabilities on hosts and local libraries"
mytool.long_description = "Exploit vulnerabilities on hosts and local libraries"


mytool.on_load = function(kernel)
    oldb = "/var/exdb"
    newdb = kernel.settings.database.location
    if newdb.is_match(oldb) then return
    if is_error(kernel.sessions[0].file.get_folder("/var/exdb")) then return

    res = confirmation_prompt("Old database location found (/var/exdb). Move to current location? ("+newdb+")")
    if not res then return

    p = Path.New(newdb)

    res = kernel.sessions[0].file.get_folder("/var/exdb").move(p.folder, p.name)
    if is_error(res) then return res.stack("exploit.on_load")
    kernel.print("$S;Moved database to " + newdb)
end function

library_names = [
    "libssh.so",
    "libftp.so",
    "libhttp.so",
    "libsql.so",
    "libsmtp.so",
    "libchat.so",
    "libcam.so",
    "librepository.so",
    "blockchain.so",
    "libadb.so",
    "libsmartappliance.so",
    "kernel_router.so",
    "aptclient.so",
    "kernel_module.so",
    "init.so",
    "net.so",
    "libtrafficnet.so",
    "metaxploit.so",
    "crypto.so",
    "librshell.so",
]

select_index = function(msg, indexes)
    if not indexes isa number then return TypeError.New("exploit.select_index", "number", typeof(indexes))
    result = null

    while result == null
        print(msg)
        inp = user_input(_global.kernel.color("$P;" + "Select index between $S;1$P; and $S;"+indexes + char(10) + "$S;: $T2;"))
        val = to_int(inp)
        if inp == "" then
            break
        else if typeof(val) != "number" then 
            print("<#e88>Invalid input")
        else if val < 1 or val > indexes then
            print("<#e88>Option out of range")
        else
            result = val-1
        end if
    end while

    return result
end function


get_exploit = function(exlib, title, ip)
    exploits = exlib.exploits_with_version()
    tab_data = []

    for exploit in exploits
        data = exploit.data(ip)
        tab_data.push([_global.kernel.color("$S;"+(len(tab_data)+1))] + data[3:])
    end for

    titles = [
        "ID",
        "Object",
        "ObjPerms",
        "Active",
        "Users",
        "Ports",
        "Local",
        "Subnet",
        "Groups",
        "Path",
        "Dependency",
        "Dep Version",
    ]

    res = tabulate_data(tab_data, titles)
    if is_error(res) then return res.stack("exploit.host")

    print("<size=30px>$P;"+title)
    print(res.string)

    log("Exploit count : " + len(exploits))
    if len(exploits) == 0 then return "No exploits found"

    selection = select_index("",len(exploits))
    if selection == null then return
    return exploits[selection]
end function


do_exploit = function(exploit, lib, ip, extra=null)
    if extra == null then
        if exploit.object == "Computer" and ((is_lan_ip(ip) and ip[-2:] == ".1") or not is_lan_ip(ip)) then
            extra = user_input(_global.kernel.color("$P;Ip to bounce to:$S; "))
        else if exploit.object == "Password" then
            extra = user_input(_global.kernel.color("$P;Password to set to:$S; "))
        end if
    end if

    result = exploit.execute(lib, extra)
    if is_error(result) then return result.stack("exploit.host")
    log(result[0] + " | " + result[1])
    log(exploit.object + " | " + exploit.objperms)
    
    update = false
    if result[0] != exploit.object and result[0] != "Unknown" then
        print("$error;Object result differs from database")
        print("$P;Database")
        print("  $S;" + exploit.object)
        print("$P;Exploit result")
        print("  $S;" + result[0])

        if confirmation_prompt("Update database?") then
            exploit.object = result[0]
            update = true
        end if
    end if

    if result[1] != exploit.objperms and result[1] != "unknown" then
        print("$P;Object result differs from database")
        print("$P;Database")
        print("  $S;" + exploit.objperms)
        print(" ")
        print("$P;Exploit result")
        print("  $S;" + result[1])
        if confirmation_prompt("Update database?") then
            exploit.objperms = result[1]
            update = true
        end if
    end if

    return [result[-1], update, extra]
end function


exploit_process = function(a, lib, ip, index=null, extra=null)
    external = false

    exlib = ExploitLibrary.New(lib)
    if is_error(exlib) then return exlib.stack("scan.exploit_process")
    e = exlib.load(a.kernel.sessions[0].computer, get_db_path(a.kernel))
    if is_error(e) then return e.stack("exploit.process")

    is_router = is_lan_ip(ip) == false
    if not is_router then
        is_router = get_router(ip) != null
    end if

    exploit = null
    if index != null then
        log("Index not null")
        res = exlib.exploits_with_version()
        if not res.hasIndex(index) then return Error.New("exploit.process", "Exploit index doesn't exist : " + index)
        exploit = res[index]
    else
        log("Index null, asking exploit")
        exploit = get_exploit(exlib, lib.lib_name, ip)
        log("Exploit selected : " + exploit)
        if is_error(exploit) then return exploit.stack("exploit.process")
    end if
    if exploit isa string then return exploit
    if exploit == null then return
    if is_router and exploit.object == "Computer" then
        external = true
    end if

    result = do_exploit(exploit, lib, ip, extra)
    if is_error(result) then return result.stack("exploit.exploit_process")
    log(result[1])
    log("Object perms : "+exploit.objperms)
    log("Object : "+exploit.object)

    if result[0] == 1 and exploit.object == "Unknown" then
        print("<#fff>Detected Firewall")
        exploit.object = "Firewall"
        exlib.save_exploits(a.kernel.sessions[0].computer)
        
    else if result[0] == 0 and exploit.object == "Unknown" then
        print("<#fff>Detected Password")
        exploit.object = "Password"
        print("<#444>[<#f4c>1<#444>]<#6af> root")
        print("<#444>[<#f4c>2<#444>]<#6af> user")
        result = select_index("<#fa0>What elevation did it have?", 2)
        if result == 0 then
            exploit.objperms = "root"
        else if result == 1 then
            exploit.objperms = "user"
        end if
        exlib.save_exploits(a.kernel.sessions[0].computer)

        if confirmation_prompt("Try exploit again with password?") then
            result = do_exploit(exploit, lib, ip, extra)
        end if

    else if result[0] == null and exploit.object == "Unknown" and is_router then
        if confirmation_prompt("Is this a bounce?") then
            exploit.object = "Computer"
            exlib.save_exploits(a.kernel.sessions[0].computer)

            if confirmation_prompt("Try again with ip bounce?") then
                result = do_exploit(exploit, lib, ip, extra)
            end if
        end if
    end if

    if is_error(result) then return result.stack("exploit.process")

    host = ip
    if is_lan_ip(result[2]) then
        host = result[2]
    end if

    if result[1] == true then
        log("Updating database")
        exlib.save_exploits(a.kernel.sessions[0].computer)
    end if
    if result[0] == null or result[0] == 0 then
        return Error.New("<#e88>Failed to exploit")
    end if
    if result[0] == true then
        //return "<#8e8>Successfully exploited"
        return true
    end if

    newses = Session.New(result[0])
    if is_error(newses) then return newses.stack("exploit.process")

    if is_lan_ip(host) then
        newses.lan = host
    else
        newses.wan = host
    end if

    return [newses, external]
end function



// host //

host_args = [
    Arg.New("ip", "ip").Info("IP of host to attack"),
    Kwarg.New("port", "int").Alias("p").Info("Port to attack"),
    Kwarg.New("stay","bool").Alias("s").Default(false).Info("Don't automatically swap to the new session"),
    Kwarg.New("index", "int").Alias("i").Info("What index to use for the exploit (only if -p is used)"),
]

host_func = function(a)
    if a.kernel.session.metax == null then return ObjectError.New("exploit.host", "metaxploit")
    if a.kernel.session.computer == null then return ObjectError.New("exploit.host", "computer")
    if not a.kernel.active_session.computer.is_network_active then return OsError.New("exploit.host", "No internet connection")

    if a.index != null and a.index <= 0 then return ValueError.New("exploit.host", "Numbers 1 and up", a.index)

    if a.port == null then
        res = a.kernel.run_command("scan " + a.ip, false)
        if not res then return
        a.port = to_int(user_input(a.kernel.color("$T2;Port $T;: $P;")))
        if a.port == "" then return
        if not a.port isa number then
            return ParseError.New("exploit.host", "Port must be a number")
        end if
    end if

    netses = a.kernel.session.metax.net_use(a.ip, a.port)

    if netses == null then return ExploitError.New("exploit.host", "Failed to get netsession")

    ports = []
    if is_lan_ip(a.ip) then
        ports = get_router().device_ports(a.ip)
    else
        ports = get_router(a.ip).used_ports()
    end if

    for port in ports 
        if port.port_number != a.port then continue
        a.ip = port.get_lan_ip
        break
    end for

    lib = netses.dump_lib()
    log(lib)
    result = null
    log("Index : "+a.index)
    if a.index != null then
        result = exploit_process(a, lib, a.ip, a.index-1)
    else
        result = exploit_process(a, lib, a.ip)
    end if

    log("result : " + result)
    if is_error(result) then return result
    if result == null or result == true then return

    // Ask for retry if no exploits found
    if result isa string then
        if result == "No exploits found" then
            print("$error;No exploits found" + char(10))
            do_scan = confirmation_prompt("Run scan command for exploits and try again?")
            if not do_scan then return Error.New("exploit.host", result)

            command = a.kernel.color(["$P;scan", "$ip;"+a.ip, "$int;--ports", a.port, "$bool;--exploits"].join(" "))
            print("$T2;> " + command)
            a.kernel.run_command(unformat_string(command), false)
            
            retry_command = ["exploit", a.ip, "-p", a.port].join(" ")
            a.kernel.run_command(retry_command)
            return
        else
            return Error.New("exploit.host", result)
        end if
    end if

    a.kernel.new_session(result[0])
    if not a.stay then
        a.kernel.run_command("session use " + result[0].id, false)
    end if

    print("$P;New session created")
    print("$S;"+ result[0].user +"$T;@$S;"+ result[0].comp_name)
    print("$T;ID:$P;"+result[0].id)
end function

host = mytool.main_command(host_args, @host_func)
host.short_description = "Run an exploit on a host"
host.long_description = "$P;Usage:
$P;exploit $ip;12.3.23.2
$P;exploit $ip;12.3.23.2 $int;--port 21
$P;exploit $ip;12.3.23.2 $int;-p 21"



// lib //

lib_args = [
    OptionalArg.New("lib", "string").Info("Library to run exploit on"),
    Kwarg.New("extra", "string").Default(null).Alias("t").Info("Extra data for exploit (Like lan pc, or password)"),
    Kwarg.New("session", "bool").Default(false).Alias("e").Info("Create a new session instead of changing current session"),
    Kwarg.New("stay", "bool").Default(false).Alias("s").Info("Don't automatically go to other session (only with -e)"),
    Kwarg.New("index", "int").Alias("i").Info("What exploit index to use (Only when lib argument is used)")
]

lib_func = function(a)
    ses = a.kernel.session
    active = a.kernel.active_session

    log(a.lib)
    log(a.extra)
    log(a.session)

    if a.index != null then a.index = a.index-1

    // if ses == a.kernel.active_sessions[0] then return ExploitError.New("exploit.lib", "Can not exploit libraries on your own system (why are you even trying this)")
    if ses != active then return ExploitError.New("exploit.lib", "Exploiting local libraries can only be done with active sessions")
    if ses.metax == null then return 

    if a.lib == null then
        a.kernel.run_command("scan libs -s", false)
        libs = ses.file.get_folder("/lib").get_files
        i = 0
        for l in libs
            i = i + 1
            print("$P;" + (i) + "$T; : $S;" + l.path)
        end for
        lib = select_index("Library to exploit:", len(libs))
        if lib == null then return
        a.lib = libs[lib].path
    end if

    lib = ses.metax.load(a.lib)
    if lib == null then return ExploitError.New("exploit.lib", "Failed to load library")

    result = exploit_process(a, lib, ses.lan, a.index, a.extra)
    if is_error(result) then return result
    if result == null then return

    if result isa string then
        if result == "No exploits found" then
            print("$error;No exploits found" + char(10))
            do_scan = confirmation_prompt("Run scan command for exploits and try again?")
            if not do_scan then return Error.New("exploit.host", result)

            command = a.kernel.color(["$P;scan libs", "$string;--library", a.lib, "$bool;--exploits"].join(" "))
            print("$T2;> " + command)
            a.kernel.run_command(unformat_string(command), false)
            
            retry_command = ["exploit lib", a.lib, "-e", a.session, "-s", a.stay].join(" ")
            a.kernel.run_command(retry_command)
            return
        else
            return Error.New("exploit.host", result)
        end if
    end if

    if result[1] then 
        create_new = (a.extra != null and a.index != null)
        if not create_new then
            create_new = confirmation_prompt("Exploit resulted in an external session. Create new session?" + char(10) + "(Session will be discarded otherwise)")
        end if
        if not create_new then return
        a.session = true
    end if

    if a.session and not a.stay then
        a.kernel.new_session(result[0])
        // a.kernel.session = result[0]
        a.kernel.run_command("session use " + result[0].id, false)
        print("$P;New session created")
    else if not a.stay then
        ses.overwrite(result[0])
        print("$P;Session overwritten")
    end if
    print("$S;"+ result[0].user +"$T;@$S;"+ result[0].comp_name)
    print("$T;ID:$P;"+result[0].id)
end function

lib = mytool.command("lib", lib_args, @lib_func)
lib.short_description = "Exploit local libraries"
lib.long_description = "$P:Usage
$P;exploit lib
$P;exploit lib $string;/lib/net.so
$P;exploit lib --session
$P;exploit lib $bool-e -s $int;-i 13 $string;/lib/net.so"



// find

find_args = [
    Arg.New("library", "string").Info("What library to search in database"),
    Arg.New("version", "string").Info("What version to look for")
]

find_func = function(a)
    if not a.version.is_match("^\d+\.\d\.\d$") then return Error.New("exploit.find", "Version must have the format: x.x.x")
    exlib = ExploitLibrary.New(a.library, str(a.version))
    if is_error(exlib) then return exlib.stack("exploit.find")
    res = exlib.load(a.kernel.sessions[0].computer, get_db_path(a.kernel))

    if is_error(res) then return res.stack("exploit.find")

    exlib.display(a.kernel, true)
end function

find = mytool.command("find", find_args, @find_func)
find.short_description = "Find exploit data stored in the database"
find.long_description = "$P;Usage:
$P;exploit find $string;libhttp.so 1.0.0
$P;exploit find $string;kernel_router.so 1.9.2"

// list

list_args = [
    Arg.New("library", "string").Info("Library to list all exploits for"),
    Kwarg.New("object", "string").Alias("o").Info("What object result to search for"),
    Kwarg.New("permission", "string").Alias("p").Info("What permission to search for"),
    Kwarg.New("active", "string").Alias("a").Info("What active user the exploit has to have"),
    Kwarg.New("users", "int").Alias("u").Info("How many users on the computer the exploit has to have"),
    Kwarg.New("ports", "int").Alias("t").Info("How many forwarded ports the exploits needs to have"),
    Kwarg.New("local", "bool").Alias("l").Info("If the exploit needs to be local only"),
    Kwarg.New("subnet", "int").Alias("s").Info("How many computers the router needs to have under it"),
    Kwarg.New("groups", "int").Alias("g").Info("How many groups the computer needs to have"),
    Kwarg.New("path", "string").Alias("h").Info("What active path the exploits needs to have"),
    Kwarg.New("dependency", "string").Alias("d").Info("What library dependency the exploits needs"),
]

list_func = function(a)
    lib_matches = []
    for x in library_names
        if x.is_match("^"+a.library) or x[3:].is_match("^"+a.library) then lib_matches.push(x)
    end for
    if len(lib_matches) != 1 then
        return OsError.New("exploit.list", "Invalid library name, use any of: " + char(10) + "   " + library_names.join(char(10)+"   "))
    end if

    if a.object != null and ["computer", "shell", "file", "unknown"].indexOf(a.object.lower) == null then
        return ParseError.New("exploit.list", "Object must be one of: computer, shell, file, unknown")
    end if
    if a.permission != null and ["root", "user", "guest", "unknown"].indexOf(a.permission.lower) then 
        return ParseError.New("exploit.list", "Object must be one of: root, user, guest, unknown")
    end if

    comp = a.kernel.sessions[0].computer

    exlib = ExploitLibrary.New(lib_matches[0], "1.0.0")
    if is_error(exlib) then return exlib.stack("epxloit.list")
    f = comp.File(get_db_path(a.kernel) + "/" + lib_matches[0])
    for x in f.get_files
        if not x.name.is_match("\d+") then continue
        if x.name == "0" then continue
        exlib.version = x.name
        exlib.load(a.kernel.sessions[0].computer, get_db_path(a.kernel))
    end for

    templib = ExploitLibrary.New(lib_matches[0], "1.0.0")
    for x in exlib.exploits
        if a.permission != null and a.permission.lower != x.objperms.lower then continue
        if a.dependency != null and a.dependency.lower != x.dependency.lower then continue
        if a.object != null and a.object.lower != x.object.lower then continue
        if a.active != null and a.active.lower != x.active.lower then continue
        if a.object != null and a.object.lower != x.object.lower then continue
        if a.path != null and a.path.lower != x.exists.lower then continue
        if a.subnet != null and a.subnet != x.subcomputers then continue
        if a.groups != null and a.groups != x.group_count then continue
        if a.users != null and a.users != x.registered then continue
        if a.ports != null and a.ports != x.ports then continue
        if a.local != null and a.local != x.local then continue

        templib.register_exploit(x)
    end for

    templib.display(a.kernel, false, true)
end function

list_cmd = mytool.command("list", list_args, @list_func)
list_cmd.short_description = "Search for exploits in the database"
list_cmd.long_description  = "$P;Usage:
$P;exploit list $string;router -o shell -p root
$P;exploit list $string;ssh $bool;--local $int;--ports 2"

// Init

mytool.init()


import_code("./crack")
import_code("./scan")
import_code("./rshell")
import_code("./brute")
import_code("./sniff")