import_code("../kernel/toolkernel")
import_code("../libs/utils")
import_code("../libs/metautils")
import_code("../libs/sessionmanager")

mytool = Tool.New("exploit", "1.6.6")

settings = Settings.init()
settings.set("database", {
    "location":"/etc/crow/exdb",
})

settings.set("color", {
    "obj_unknown"   : "<#444>",
    "obj_file"      : "<#68f>",
    "obj_computer"  : "<#b72>",
    "obj_shell"     : "<#b22>",
    "obj_firewall"  : "<#94f>",
    "obj_password"  : "<#888>",
    "obj_bounce"    : "<#4cc>",
    "unknown"       : "<#444>",
    "none"          : "<#444>",
    "guest"         : "<#46b>",
    "user"          : "<#b72>",
})

mytool.settings = settings


mytool.short_description = "Exploit vulnerabilities on hosts and local libraries"
mytool.long_description = "Exploit vulnerabilities on hosts and local libraries"


mytool.on_load = function(kernel)
    oldb = "/var/exdb"
    newdb = kernel.settings.database.location
    if newdb.is_match(oldb) then return
    if is_error(kernel.sessions[0].file.get_folder("/var/exdb")) then return

    res = confirmation_prompt("Old database location found (/var/exdb). Move to current location? ("+newdb+")")
    if not res then return

    p = Path.New(newdb)

    res = kernel.sessions[0].file.get_folder("/var/exdb").move(p.folder, p.name)
    if is_error(res) then return res.stack("exploit.on_load")
    kernel.print("$S;Moved database to " + newdb)
end function


// host //

host_args = [
    Arg.New("ip", "ip").Info("IP of host to attack"),
    Kwarg.New("port", "int").Alias("p").Info("Port to attack"),
    Kwarg.New("stay","bool").Alias("s").Info("Don't automatically swap to the new session"),
    Kwarg.New("index", "int").Alias("i").Info("What index to use for the exploit (only if -p is used)"),
]

host_func = function(a)
    target_ip = a.ip
    if a.kernel.session.metax == null then return ObjectError.New("exploit.host", "metaxploit")
    if a.kernel.session.computer == null then return ObjectError.New("exploit.host", "computer")
    if not a.kernel.active_session.computer.is_network_active then return OsError.New("exploit.host", "No internet connection")

    if a.index != null and a.index <= 0 then return ValueError.New("exploit.host", "Numbers 1 and up", a.index)

    if a.port == null then
        res = a.kernel.run_command("scan " + a.ip, false)
        if not res then return
        a.port = to_int(user_input(a.kernel.color("$T2;Port $T;: $P;")))
        if a.port == "" then return
        if not a.port isa number then
            return ParseError.New("exploit.host", "Port must be a number")
        end if
    end if

    netses = a.kernel.session.metax.net_use(a.ip, a.port)

    if netses == null then return ExploitError.New("exploit.host", "Failed to get netsession")

    ports = []
    if is_lan_ip(a.ip) then
        ports = get_router().device_ports(a.ip)
    else
        ports = get_router(a.ip).used_ports()
    end if

    for port in ports 
        if port.port_number != a.port then continue
        a.ip = port.get_lan_ip
        break
    end for

    lib = netses.dump_lib()
    log(lib)
    result = null
    log("Index : "+a.index)
    if a.index != null then
        result = exploit_process(a.kernel, lib, a.ip, a.index-1)
    else
        result = exploit_process(a.kernel, lib, a.ip)
    end if

    log("result : " + result)

    // Ask for retry if no exploits found
    if is_error(result) and result.message.is_match("No exploits found$") then
        print("$error;No exploits found" + char(10))
        do_scan = confirmation_prompt("Run scan command for exploits and try again?")
        if not do_scan then return result.stack("exploit.host")

        command = a.kernel.color(["$P;scan", "$ip;" + target_ip, "$int;--ports", a.port, "$bool;--exploits"].join(" "))
        print("$T2;> " + command)
        a.kernel.run_command(unformat_string(command), false)
        
        retry_command = ["exploit", a.ip, "-p", a.port].join(" ")
        a.kernel.run_command(retry_command)
        return
    end if

    if result isa string then
        return Error.New("exploit.host", result)
    end if

    if is_error(result) then return result
    if result == null or result == true then return

    a.kernel.new_session(result[0])
    if not a.stay then
        a.kernel.run_command("session use " + result[0].id, false)
    end if

    print("$P;New session created")
    print("$S;"+ result[0].user +"$T;@$S;"+ result[0].comp_name)
    print("$T;ID:$P;"+result[0].id)
end function

host = mytool.main_command(host_args, @host_func)
host.short_description = "Run an exploit on a host"
host.long_description = "$P;Usage:
$P;exploit $ip;12.3.23.2
$P;exploit $ip;12.3.23.2 $int;--port 21
$P;exploit $ip;12.3.23.2 $int;-p 21"



// lib //

lib_args = [
    OptionalArg.New("lib", "string").Info("Library to run exploit on"),
    Kwarg.New("extra", "string").Default(null).Alias("t").Info("Extra data for exploit (Like lan pc, or password)"),
    Kwarg.New("session", "bool").Alias("e").Info("Create a new session instead of changing current session"),
    Kwarg.New("stay", "bool").Alias("s").Info("Don't automatically go to other session (only with -e)"),
    Kwarg.New("index", "int").Alias("i").Info("What exploit index to use (Only when lib argument is used)")
]

lib_func = function(a)
    ses = a.kernel.session
    active = a.kernel.active_session

    log(a.lib)
    log(a.extra)
    log(a.session)

    if a.index != null then a.index = a.index-1

    // if ses == a.kernel.active_sessions[0] then return ExploitError.New("exploit.lib", "Can not exploit libraries on your own system (why are you even trying this)")
    if ses != active then return ExploitError.New("exploit.lib", "Exploiting local libraries can only be done with active sessions")
    if ses.metax == null then return 

    if a.lib == null then
        a.kernel.run_command("scan libs -s", false)
        libs = ses.file.get_folder("/lib").get_files
        i = 0
        for l in libs
            i = i + 1
            print("$P;" + (i) + "$T; : $S;" + l.path)
        end for
        lib = select_index("Library to exploit:", len(libs))
        if lib == null then return
        a.lib = libs[lib].path
    end if

    lib = ses.metax.load(a.lib)
    if lib == null then return ExploitError.New("exploit.lib", "Failed to load library")

    result = exploit_process(a.kernel, lib, ses.lan, a.index, a.extra)
    if is_error(result) then return result
    if result == null or result == 1 then return

    if is_error(result) and result.message.is_match("No exploits found$") then
        print("$error;No exploits found" + char(10))
        do_scan = confirmation_prompt("Run scan command for exploits and try again?")
        if not do_scan then return result.stack("exploit.host")

        command = a.kernel.color(["$P;scan", "$ip;"+a.ip, "$int;--ports", a.port, "$bool;--exploits"].join(" "))
        print("$T2;> " + command)
        a.kernel.run_command(unformat_string(command), false)
        
        retry_command = ["exploit", a.ip, "-p", a.port].join(" ")
        a.kernel.run_command(retry_command)
        return
    end if

    if result isa string then
        return Error.New("exploit.host", result)
    end if

    if result[1] then 
        create_new = (a.extra != null and a.index != null)
        if not create_new then
            create_new = confirmation_prompt("Exploit resulted in an external session. Create new session?" + char(10) + "(Session will be discarded otherwise)")
        end if
        if not create_new then return
        a.session = true
    end if

    a.kernel.new_session(result[0])
    if a.session and not a.stay then
        // a.kernel.session = result[0]
        a.kernel.run_command("session use " + result[0].id, false)
        print("$P;New session created")
    else if not a.stay then
        ses.overwrite(result[0])
        print("$P;Session overwritten")
    end if
    print("$S;"+ result[0].user +"$T;@$S;"+ result[0].comp_name)
    print("$T;ID:$P;"+result[0].id)
end function

lib = mytool.command("lib", lib_args, @lib_func)
lib.short_description = "Exploit local libraries"
lib.long_description = "$P:Usage
$P;exploit lib
$P;exploit lib $string;/lib/net.so
$P;exploit lib --session
$P;exploit lib $bool-e -s $int;-i 13 $string;/lib/net.so"


// list

list_args = [
    Arg.New("library", "string").Info("Library to list all exploits for"),
    Kwarg.New("object", "string").Alias("o").Info("What object result to search for"),
    Kwarg.New("permission", "string").Alias("p").Info("What permission to search for"),
    Kwarg.New("active", "string").Alias("a").Info("What active user the exploit has to have"),
    Kwarg.New("users", "int").Alias("u").Info("How many users on the computer the exploit has to have"),
    Kwarg.New("ports", "int").Alias("t").Info("How many forwarded ports the exploits needs to have"),
    Kwarg.New("local", "bool").Alias("l").Info("If the exploit needs to be local only"),
    Kwarg.New("subnet", "int").Alias("s").Info("How many computers the router needs to have under it"),
    Kwarg.New("groups", "int").Alias("g").Info("How many groups the computer needs to have"),
    Kwarg.New("path", "string").Alias("h").Info("What active path the exploits needs to have"),
    Kwarg.New("dependency", "string").Alias("d").Info("What library dependency the exploits needs"),
    Kwarg.New("version", "string").Alias("v").Info("What version of the library to look for"),
    Kwarg.New("show_details", "bool").Alias("s").Info("Show all details for the exploit")
]

list_func = function(a)
    lib_matches = []
    for x in library_names
        if x.is_match("^"+a.library) or x[3:].is_match("^"+a.library) then lib_matches.push(x)
    end for
    if len(lib_matches) != 1 then
        return OsError.New("exploit.list", "Invalid library name, use any of: " + char(10) + "   " + library_names.join(char(10)+"   "))
    end if

    if a.object != null and ["computer", "shell", "file", "unknown", "password", "firewall"].indexOf(a.object.lower) == null then
        return ParseError.New("exploit.list", "Object must be one of: computer, shell, file, password, firewall, unknown")
    end if
    if a.permission != null and ["root", "user", "guest", "unknown"].indexOf(a.permission.lower) then 
        return ParseError.New("exploit.list", "Object must be one of: root, user, guest, unknown")
    end if
    if a.version != null and not (a.version.is_match("^\d+\.\d\.\d$") or a.version.is_match("^\d{3}\d*$")) then
        return ParseError.New("exploit.list", "Version should match the following pattern: x.x.x or xxx. Got " + a.version)
    end if

    check_version = "1.0.0"
    if a.version != null then
        if a.version.is_match("\d+\.\d\.\d") then
            check_version = a.version
        else
            check_version = a.version[:-2] + "." + a.version[-2] + "." + a.version[-1]
        end if
    end if

    comp = a.kernel.sessions[0].computer

    exlib = ExploitLibrary.New(lib_matches[0], check_version)
    if is_error(exlib) then return exlib.stack("exploit.list")
    f = comp.File(get_db_path(a.kernel) + "/" + lib_matches[0])
    if not is_error(f) then
        for x in f.get_files
            if not x.name.is_match("\d+") then continue
            if x.name == "0" then continue
            exlib.version = x.name
            exlib.load(a.kernel.sessions[0].computer, get_db_path(a.kernel))
        end for
    end if
    templib = ExploitLibrary.New(lib_matches[0], check_version)
    for x in exlib.exploits
        if a.permission != null and a.permission.lower != x.objperms.lower then continue
        if a.dependency != null and a.dependency.lower != x.dependency.lower then continue
        if a.object != null and a.object.lower != x.object.lower then continue
        if a.active != null and a.active.lower != x.active.lower then continue
        if a.object != null and a.object.lower != x.object.lower then continue
        if a.path != null and a.path.lower != x.exists.lower then continue
        if a.subnet != null and a.subnet != x.subcomputers then continue
        if a.groups != null and a.groups != x.group_count then continue
        if a.users != null and a.users != x.registered then continue
        if a.ports != null and a.ports != x.ports then continue
        if a.local != null and a.local != x.local then continue

        templib.register_exploit(x)
    end for

    templib.display(a.kernel, a.version != null, not a.show_details)
end function

list_cmd = mytool.command("list", list_args, @list_func)
list_cmd.short_description = "Search for exploits in the database"
list_cmd.long_description  = "$P;Usage:
$P;exploit list $string;router -o shell -p root
$P;exploit list $string;ssh $bool;--local $int;--ports 2"

// Init

mytool.init()


import_code("./crack")
import_code("./scan")
import_code("./rshell")
import_code("./brute")
import_code("./sniff")
import_code("./zday")