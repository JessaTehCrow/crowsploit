import_code("./error")
import_code("./typehandler")


File = {}
File.object = null
File.type = "file"
File.partial = false
File.show_corrupt = false

File.has = function(name)
    return self.object.__isa.hasIndex(name)
end function

File.New = function(obj, root=null)
    if not typeof(obj).is_match("(?:ftp)?[fF]ile$") then return TypeError.New("File.New","file", typeof(obj))
    file = new self
    file.object = obj

    file.root_path = root
    if root == null then
        temp = obj
        while temp.path != "/" 
            temp = temp.parent
        end while
        file.root_path = temp
    end if

    return file
end function

File.sanity_check = function()
    if self.status == 0 then return
    self.object = self.root_path
    if self.show_corrupt then print("<#e88>File deleted or corrupted, resetting to /")
end function

File.path = function(original_path=false)
    self.sanity_check
    if not self.has("path") then return PartialObjectError.New("file", "path")
    return self.object.path(original_path)
end function

File.copy = function(path, name)
    self.sanity_check
    if not self.has("copy") then return PartialObjectError.New("file", "copy")
    err = expect_all([path, name], string)
    if err != null then return TypeError.New("File.copy","string", err)
    result = self.object.copy(path, name)
    if result isa string then return Error.New("File.copy",result)
end function

File.is_folder = function()
    self.sanity_check
    if not self.has("is_folder") then return PartialObjectError.New("file", "is_folder")
    return self.object.is_folder
end function

File.is_file = function()
    self.sanity_check
    return not (self.is_folder or self.is_binary)
end function

File.is_symlink = function()
    self.sanity_check
    if not self.has("is_symlink") then return PartialObjectError.New("file", "is_symlink")
    return self.object.is_symlink
end function

File.is_binary = function()
    self.sanity_check
    if not self.has("is_binary") then return PartialObjectError.New("file", "is_binary")
    return self.object.is_binary
end function

File.file_type = function(resolve_symlink=false)
    self.sanity_check
    if self.is_symlink and resolve_symlink == false then return "symlink"
    if self.is_folder then return "folder"
    if self.is_binary then return "binary"
    if self.is_file and self.name.is_match(".+\.src") then return "code"
    if self.is_file then return "file"
end function

File.permissions = function()
    self.sanity_check
    if not self.has("permissions") then return PartialObjectError.New("file", "permissions")
    return self.object.permissions
end function

File.has_permission = function(perm)
    self.sanity_check
    if not self.has("has_permission") then return PartialObjectError.New("file", "has_permission")
    if self.permissions == null then return true
    if not perm isa string then return TypeError.New("File.has_permission","string", typeof(perm))
    if not perm.is_match("^(?!.*(.).*\1)[rwx]{1,3}$") then return FormatError.New("File.has_permission","rwx", perm)
    for x in perm
        if not self.object.has_permission(x) then return false
    end for
    return true
end function

File.chmod = function(perms, recursive=false)
    self.sanity_check
    if not self.has("chmod") then return PartialObjectError.New("file", "chmod")
    if not perms isa string then return TypeError.New("File.chmod","string", typeof(perms))
    binary = function(n)
    b = []
    while n > 0
        b.push(n % 2)
        n = floor(n / 2)
    end while
    while b.len < 3
        b.push(0)
    end while
    b.reverse
    return b
    end function
    queries = []
    if perms.indexOf("+") != null then
        u = perms.split("\+")[0]
        p = perms.split("\+")[1]
        if u == "" then u = "ugo"
        if p == "" then p = "wrx"
        for i in u
            for j in p
                queries = queries.push(i+"+"+j)	
            end for
        end for
    else if perms.indexOf("-") != null then
        u = perms.split("-")[0]
        p = perms.split("-")[1]
        if u == "" then u = "ugo"
        if p == "" then p = "wrx"
        for i in u
            for j in p
                queries = queries.push(i+"-"+j)	
            end for
        end for
    else if typeof(perms.to_int) == "number" and perms.len == 3 then
        u = perms[0].to_int
        g = perms[1].to_int
        o = perms[2].to_int
        repl = {1:"+",0:"-"}
        b = [binary(u),binary(g),binary(o)]
        queries = queries + ["u"+repl[b[0][0]]+"r","u"+repl[b[0][1]]+"w","u"+repl[b[0][2]]+"x"]
        queries = queries + ["g"+repl[b[1][0]]+"r","g"+repl[b[1][1]]+"w","g"+repl[b[1][2]]+"x"]
        queries = queries + ["o"+repl[b[2][0]]+"r","o"+repl[b[2][1]]+"w","o"+repl[b[2][2]]+"x"]
    else if perms.indexOf("=") != null then
        u = perms.split("=")[0]
        p = perms.split("=")[1]
        if u == "" or p == "" then 
            return FormatError.New("File.chmod","Invalid permissions given")
            return
        end if
        
        for i in u
            queries = queries.push(i+"-"+"rwx")
                for j in p
                    queries = queries.push(i+"+"+j)	
                end for
        end for
    else
        return FormatError.New("File.chmod","Invalid permissions given")
    end if
    for q in queries
        err = self.object.chmod(q, recursive)
        if err == "permission denied" then return PermissionError.New("File.chmod","write or owner")
        if err != "" then return Error.New("File.chmod",err)
    end for
    //print("$T;Set new permissions to $P;" + target.permissions)
    return true
        //if not self.has_permission("w") then return PermissionError.New("File.set_permission","write")
        //if not perm isa string then return TypeError.New("File.set_permission","string", typeof(perm))

        //if not perm.is_match("^[oug][+-](?!.*(.).*\1)[rwx]{1,3}$") then
        //    return FormatError.New("File.set_permission","[oug][+-][rwx]")
        //end if
        //result = self.object.chmod(perm, recursive)
end function

File.delete = function()
    self.sanity_check
    if not self.has("delete") then return PartialObjectError.New("file", "delete")
    if self.path == "/" then return OsError.New("File.delete","Cannot delete root folder")
    if not self.partial and not self.is_symlink and not self.parent.has_permission("w") then return PermissionError.New("File.delete","write")
    err = self.object.delete
    if err != "" then return Error.New("File.delete", err)
end function

File.get_content = function()
    self.sanity_check
    if not self.has("get_content") then return PartialObjectError.New("file", "get_content")
    if not self.is_file then return TypeError.New("File.get_content","file", self.file_type)
    if not self.has_permission("r") then return PermissionError.New("File.get_content","read")

    return self.object.get_content()
end function

File.get_folders = function()
    self.sanity_check
    if not self.has("get_folders") then return PartialObjectError.New("file", "get_folders")
    if not self.is_folder then return TypeError.New("File.get_folders","folder", self.file_type)

    result = []
    for folder in self.object.get_folders 
        result.push(File.New(folder, self.root_path))
    end for

    return result
end function

File.get_files = function()
    self.sanity_check
    if not self.has("get_files") then return PartialObjectError.New("file", "get_files")
    if not self.is_folder then return TypeError.New("File.get_files","folder", self.file_type)

    result = []
    for file in self.object.get_files 
        result.push(File.New(file, self.root_path))
    end for
    
    return result
end function

File.group = function()
    self.sanity_check
    if not self.has("group") then return PartialObjectError.New("file", "group")
    o = self.object.group
    if o == null then return "null"
    return self.object.group
end function

File.move = function(path, name)
    self.sanity_check
    if not self.has("move") then return PartialObjectError.New("file", "move")
    if not path isa string then return TypeError.New("File.move","string", typeof(path))
    if not name isa string then return TypeError.New("File.move","string", typeof(name))

    if self.path == "/" then return OsError.New("File.move","Cannot move root folder")
    if not self.partial and not self.parent.has_permission("w") then return PermissionError.New("File.move","write")
    result = self.object.move(path, name)
    if result isa string then return Error.New("File.move", result)
end function

File.name = function()
    self.sanity_check
    if not self.has("name") then return PartialObjectError.New("file", "name")
    o = self.object.name
    if o == null then return "null"
    return self.object.name
end function

File.owner = function()
    self.sanity_check
    if not self.has("owner") then return PartialObjectError.New("file", "owner")
    o = self.object.owner
    if o == null then return "null"
    return o
end function

File.parent = function()
    self.sanity_check
    if not self.has("parent") then return PartialObjectError.New("file", "parent")
    parent = self.object.parent
    if parent == null then return self

    return File.New(parent, self.root_path)
end function

File.rename = function(name)
    self.sanity_check
    if not self.has("rename") then return PartialObjectError.New("file", "rename")
    if not name isa string then return TypeError.New("File.rename","string", typeof(name))
    if self.path == "/" then return OsError.New("File.rename","Cannot move root folder")
    if not self.partial and not self.parent.has_permission("w") then return PermissionError.New("File.rename","write")
    result = self.object.rename(name)
    if result isa string and result != "" then return Error.New("File.rename",result)
end function

File.set_content = function(content)
    self.sanity_check
    if not self.has("set_content") then return PartialObjectError.New("file", "set_content")
    if not self.parent.has_permission("w") then return PermissionError.New("File.set_content","write")
    result = self.object.set_content(content)
    if result isa string then return Error.New("File.set_content",result)
end function

File.set_group = function(group, recursive=false)
    self.sanity_check
    if not self.has("set_group") then return PartialObjectError.New("file", "set_group")
    if not self.has_permission("w") then return PermissionError.New("File.set_group","write")
    if not group then return OsError.New("File.set_group","Group cannot be empty")
    if group.len > 15 then return OsError.New("File.set_group","Group cannot exceed 15 characters")
    result = self.object.set_group(group, recursive)
    if result == "Permission denied" then return PermissionError.New("File.set_group","write")
    if result == "" then return
    if result isa string then return Error.New("File.set_group", result)
end function

File.set_owner = function(owner, recursive=false)
    self.sanity_check
    if not self.has("set_owner") then return PartialObjectError.New("file", "set_owner")
    if not self.has_permission("w") then return PermissionError.New("File.set_owner","write")
    if not owner then return OsError.New("File.set_owner","Owner cannot be empty")
    if owner.len > 15 then return OsError.New("File.set_owner","Owner cannot exceed 15 characters")
    result = self.object.set_owner(owner, recursive)
    if result == "Permission denied" then return PermissionError.New("File.set_group","write")
    if result == "" then return
    if result isa string then return Error.New("File.set_owner", result)
end function

File.size = function()
    self.sanity_check
    if not self.has("size") then return PartialObjectError.New("file", "size")
    return self.object.size
end function

File.symlink = function(destination, name)
    self.sanity_check
    if not self.has("symlink") then return PartialObjectError.New("file", "symlink")
    if len(name) > 128 then return OsError.New("File.symlink","Filename cannot be longer than 128 characters")
    //if not self.has_permission("w") then return PermissionError.New("File.symlink", "read")
    if not is_error(self.get_path(destination+"/"+name)) then return OsError.New("File.symlink", "Path already exists : " + destination+"/"+name)
    target_folder = self.get_folder(destination)
    if is_error(target_folder) then return target_folder.stack("File.symlink")
    if not target_folder.has_permission("w") then return PermissionError.New("File.symlink", "write")

    res = self.object.symlink(destination, name)
    if res isa string then return OsError.New("File.symlink", res)
    return res
end function

// @description a return value of 0 = FileOK
// @description a return value of 1 = BrokenSymlink
// @description a return value of 2 = FileDeleted
// @returns {0|1|2}
File.status = function()
    if not self.has("owner") then return 0
    if not self.has("is_symlink") then return 0
    if self.object == null then return 2
    if self.object.owner == null then 
        return 2 - self.object.is_symlink
    end if
    return 0
end function


Computer = {}
Computer.object = null
Computer.type = "computer"
Computer.partial = false

Computer.New = function(obj)
    if not typeof(obj).is_match("(?:ftp)?[cC]omputer$") then return TypeError.New("Computer.New","computer", typeof(obj))
    comp = new Computer
    comp.object = obj
    return comp
end function

Computer.has = function(name)
    result = self.object.__isa.hasIndex(name)
    return self.object.__isa.hasIndex(name)
end function

Computer.File = function(path)
    if not self.has("File") then return PartialObjectError.New("computer", "File")
    if not path isa string then return TypeError.New("Computer.file","string", typeof(path))
    file = self.object.File(path)
    if file == null then return OsError.New("Computer.file","Could not retrieve file from computer ("+path+")")
    return File.New(file)
end function

Computer.active_net_card = function()
    if not self.has("active_net_card") then return PartialObjectError.New("computer", "active_net_card")
    return self.object.active_net_card
end function

Computer.change_password = function(user, password)
    if not self.has("change_password") then return PartialObjectError.New("computer", "change_password")
    err = expect_all([user, password], string)
    if err != null then return TypeError.New("Computer.change_password","string", err)
    result = self.object.change_password(user, password)
    if result isa string then return Error.New("Computer.change_password",result)
end function

Computer.close_program = function(pid)
    if not self.has("close_program") then return PartialObjectError.New("computer", "close_program")
    if not pid isa number then return TypeError.New("Computer.close_program","number", typeof(pid))
    result = self.object.close_program(pid)
    if result isa string then return Error.New("Computer.close_program",result)
end function

Computer.connect_ethernet = function(netDevice, local, gateway)
    if not self.has("connect_ethernet") then return PartialObjectError.New("computer", "connect_ethernet")
    err = expect_all([netDevice, local, gateway],string)
    if err != null then return TypeError.New("Computer.connect_ethernet","string", err)
    if not self.is_network_active then return OsError.New("Computer.connect_ethernet","No internet connection")
    result = self.object.connect_ethernet(netDevice, local, gateway)
    if result != "" then return Error.New("Computer.connect_ethernet",result)
end function

Computer.connect_wifi = function(netDevice, bssid, essid, pass)
    if not self.has("connect_wifi") then return PartialObjectError.New("computer", "connect_wifi")
    err = expect_all([netDevice, bssid, essid, pass], string)
    if err != null then return TypeError.New("connect_wifi","string", err)
    result = self.object.connect_wifi(netDevice, bssid, essid, pass)
    if result isa string then return Error.New("Computer.connect_wifi",result)
end function

Computer.create_folder = function(path, name)
    if not self.has("create_folder") then return PartialObjectError.New("computer", "create_folder")
    if not path isa string then return TypeError.New("Computer.create_folder","string", typeof(path))
    if not name isa string then return TypeError.New("Computer.create_folder","string", typeof(name))
    result = self.object.create_folder(path, name)
    if result isa string then return Error.New("Computer.create_folder",result)
end function

Computer.create_group = function(user, group)
    if not self.has("create_group") then return PartialObjectError.New("computer", "create_group")
    if not user isa string then return TypeError.New("Computer.create_group","string", typeof(user))
    if not group isa string then return TypeError.New("Computer.create_group","string", typeof(group))
    if user == "" or group == "" then return OsError.New("Computer.create_group", "User and Group cannot be empty")
    if len(user) > 15 then return OsError.New("Computert.delete_group", "User cannot exceed 15 characters")
    result = self.object.create_group(user, group)
    if result isa string then return Error.New("Computer.create_group",result)
    if result == null then return Error.New("Computer.create_group", "Failed to create group for user")
end function

Computer.delete_group = function(user, group)
    if not self.has("delete_group") then return PartialObjectError.New("computer", "delete_group")
    if not user isa string then return TypeError.New("Computer.delete_group","string", typeof(user))
    if not group isa string then return TypeError.New("Computer.delete_group","string", typeof(group))
    if user == "" or group == "" then return OsError.New("Computer.delete_group", "User and Group cannot be empty")
    if len(user) > 15 then return OsError.New("Computer.delete_group", "User cannot exceed 15 characters")
    result = self.object.delete_group(user, group)
    if result isa string then return Error.New("Computer.delete_group",result)
    if result == null then return Error.New("Computer.delete_group", "Failed to create group for user")
end function

Computer.create_user = function(name, pass)
    if not self.has("create_user") then return PartialObjectError.New("computer", "create_user")
    if not name isa string then return TypeError.New("Computer.create_user","string", typeof(name))
    if not pass isa string then return TypeError.New("Computer.create_user","string", typeof(pass))
    if name == "" then return OsError.New("Computer.create_user", "Username cannot be empty")
    if len(name) > 15 or len(pass) > 15 then return OsError.New("Computer.create_user", "Username and Password cannot exceed 15 characters")

    result = self.object.create_user(name, pass)
    if result == null then return Error.New("Computer.create_user", "Failed to create user")
    if result isa string then return Error.New("Computer.create_user",result)
end function

Computer.delete_user = function(user, remove_home=false)
    if not self.has("delete_user") then return PartialObjectError.New("computer", "delete_user")
    if not user isa string then return TypeError.New("Computer.delete_user","string", typeof(user))
    if user == "" then return Error.New("Computer.delete_user", "Username cannot be empty")
    if not remove_home isa number then return TypeError.New("Computer.delete_user","number", typeof(remove_home))
    if remove_home != false or remove_home != true then ValueError.New("Computer.delete_user","0,1", str(remove_home))

    result = self.object.delete_user(user, remove_home)
    if result == null then return Error.New("Computer.delete_user", "Failed to create user")
    if result isa string then return Error.New("Computer.delete_user",result)
end function

Computer.get_name = function()
    if not self.has("get_name") then return PartialObjectError.New("computer", "get_name")
    return self.object.get_name
end function

Computer.get_ports = function()
    if not self.has("get_ports") then return PartialObjectError.New("computer", "get_ports")
    return self.object.get_ports
end function

Computer.groups = function(user)
    if not self.has("groups") then return PartialObjectError.New("computer", "groups")
    if not user isa string then return TypeError.New("Computer.groups","string", typeof(user))
    if user == "" then return FormatError.New("Computer.groups", "Username", "Empty string")
    result = self.object.groups(user)
    if not result then return OsError.New("Computer.groups", "No user found with name '"+user+"'")
    return result
end function

Computer.is_network_active = function()
    if not self.has("is_network_active") then return PartialObjectError.New("computer", "is_network_active")
    file = self.File("/")
    critfilepaths = ["/etc/xorg.conf","/lib/net.so","/lib/init.so","/sys/xorg.sys","/sys/config.sys","/sys/network.cfg","/boot/System.map","/boot/initrd.img","/boot/kernel.img"]
    for path in critfilepaths
        if is_error(file.get_path(path)) then return false
    end for
    return self.object.is_network_active
end function

Computer.local_ip = function()
    if not self.has("local_ip") then return PartialObjectError.New("computer", "local_ip")
    return self.object.local_ip
end function

Computer.network_devices = function()
    if not self.has("network_devices") then return PartialObjectError.New("computer", "network_devices")
    return self.object.network_devices
end function

Computer.network_gateway = function()
    if not self.has("network_gateway") then return PartialObjectError.New("computer", "network_gateway")
    return self.object.network_gateway
end function

Computer.public_ip = function()
    if not self.has("public_ip") then return PartialObjectError.New("computer", "public_ip")
    return self.object.public_ip
end function

Computer.show_procs = function()
    if not self.has("show_procs") then return PartialObjectError.New("computer", "show_procs")
    return self.object.show_procs
end function

Computer.touch = function(path, file, content)
    if not self.has("touch") then return PartialObjectError.New("computer", "touch")
    err = expect_all([path, file, content], string)
    if err != null then return TypeError.New("Computer.touch","string", typeof(err))
    if file == "" then return OsError.New("Computer.touch", "Filename cannot be empty")

    /////////////////////////////////
    /////backwords compatibility/////

    result = self.object.touch(path, file)
    if result isa string and result.indexOf("does not exist") != null then 
        if path[-1] == "/" then path = path[:-1]
        new_path = path.split("/")[1:]
        for p in range(0, new_path.len - 1)
            target = "/" + new_path[:p + 1].join("/")
            if not self.object.File(target) then 
                error = self.object.create_folder(parent_path(target), target.split("/")[-1])
                if error isa string then return Error.New("Computer.touch", error)
            end if
        end for
    end if


    if result != 1 then result = self.object.touch(path, file)
    if result isa string then return Error.New("Computer.touch",result)
    if content == null then return
    wait(0.02)
    file = self.File(path+"/"+file)
    if is_error(file) then return file.stack("Computer.touch")
    file.set_content(content)
end function

Computer.wifi_networks = function(interface)
    if not self.has("wifi_networks") then return PartialObjectError.New("computer", "wifi_networks")
    if not interface isa string then return TypeError.New("Computer.wifi_networks", "string", typeof(interface))
    if self.object.active_net_card != "WIFI" then return OsError.New("computer.wifi_networks","Wifi card isnt enabled")
    return self.object.wifi_networks(interface)
end function

Computer.reboot = function(safeMode = false)
    if not self.has("reboot") then return PartialObjectError.New("computer", "reboot")
    if not safeMode isa number then return TypeError.New("Computer.reboot", "number", typeof(safeMode))
    result = self.object.reboot(safeMode)
    if result isa string then return Error.New("Computer.reboot",result)
end function




Shell = {}
Shell.object = null
Shell.type = "shell"

Shell.New = function(obj)
    if not typeof(obj).is_match("(?:ftp)?[sS]hell$") then return Error.New("Shell.New","shell", typeof(obj))
    shell = new Shell
    shell.object = obj
    return shell
end function

Shell.has = function(name)
    result = self.object.__isa.hasIndex(name)
    return self.object.__isa.hasIndex(name)
end function

Shell.host_computer = function()
    // if not self.has("host_computer") then return PartialObjectError.New("shell", "host_computer")
    comp = host_computer(self.object)
    if comp == null then return Error.New("Shell.host_computer","Could not retrieve computer from shell")
    return Computer.New(comp)
end function

Shell.File = function(path)
    comp = self.host_computer
    if is_error(comp) then return comp.stack("Shell.File")

    file = comp.File(path)
    if is_error(file) then return file.stack("Shell.File")
    
    return file
end function

Shell.build = function(source, result, allowImport=false)
    if not self.has("build") then return PartialObjectError.New("shell", "build")
    err = expect_all([source, result], string)
    if err != null then return TypeError.New("Shell.build","string", typeof(err))
    if not allowImport isa number then return TypeError.New("Shell.build","number", typeof(allowImport))

    if allowImport != 1 and allowImport != 0 then return ValueError.New("Shell.build","0,1", str(allowImport))
    res = build(self.object, source, result, allowImport)
    if res != "" then return Error.New("shell.build", res)
    return res
end function

Shell.launch = function(program, args)
    if not self.has("launch") then return PartialObjectError.New("shell", "launch")
    err = expect_all([program], string)
    if err != null then return TypeError.New("Shell.launch","string", typeof(err))
    if typeof(args) != "null" and not args isa string then return TypeError.New("Shell.launch","string", typeof(args))

    result = null
    if args == null then
        result = launch(self.object, program)
        // result = self.object.launch(program)
    else
        result = launch(self.object, program, args)
        // result = self.object.launch(program, args)
    end if

    if result isa string then return Error.New("Shell.launch",result)
    return result
end function

Shell.scp = function(file, target, remote, is_upload = false)
    if not self.has("scp") then return PartialObjectError.New("shell", "scp")
    err = expect_all([file, target], string)
    if err != null then return TypeError.New("Shell.scp","string", typeof(err))
    if remote.type != "shell" then return TypeError.New("Shell.scp","shell", typeof(remote))

    test_file = self.File(file)
    if is_error(test_file) then return test_file.stack("Shell.scp")
    if not test_file.has_permission("r") then return PermissionError.New("Shell.scp","read")

    folder = remote.host_computer.File(target)
    if is_error(folder) then return folder.stack("Shell.scp")
    if not folder.has_permission("w") then return PermissionError.New("Shell.scp","write")

    // result = self.object.scp(file, target, remote)
    result = null
    result = scp(self.object, file, target, remote.object, is_upload)


    if result == null then return Error.New("shell.scp", "Failed to copy file")
    if result isa string then return Error.New("Shell.scp",result)
    return result
end function

Shell.start_terminal = function()
    if not self.has("start_terminal") then return PartialObjectError.New("shell", "start_terminal")
    start_terminal(self.object)
end function

Shell.ping = function(ip)
    if not self.has("ping") then return PartialObjectError.New("shell", "ping")
    err = expect_all([ip], string)
    if err != null then return TypeError.New("Shell.ping", typeof(ip))
    result = ping(self.object, ip)

    if result isa string then return Error.New("Shell.ping", result)

    return result
end function

Shell.connect_service = function(ip, port, user, password, service)
    if not self.has("connect_service") then return PartialObjectError.New("shell", "connect_service")
    err = expect_all([ip, user, password, service], string)
    if err != null then return TypeError.New("Shell.connect_service", typeof(err))
    if not port isa number then return TypError.New("Shell.connect_service", typeof(port))
    if not self.host_computer.is_network_active then return OsError.New("Shell.connect_service","No internet connection")

    result = connect_service(self.object, ip, port, user, password, service)
    if result isa string then return Error.New("Shell.connect_service", result)
    if result == null then return Error.New("Shell.connect_service", "read thing above, i don't receive it for some reason")
    return Shell.New(result)
end function
