import_code("./proxies")
Path = {}
Path.slices = null
 
Path.New = function(full_path)
    if not full_path isa string then return TypeError.New("Path.new", "string", typeof(full_path))
    if full_path == "" then return FormatError.New("Path.New", "Full system path", "Empty string")
    if full_path[0] != "/" then return FormatError.New("Path.New", "Full system path", full_path)

    p = new self
    p.slices = []
    slices = full_path.split("/")[1:]

    temp = slices.join("/")
    if temp != "" then
        p.change(slices.join("/"))
    end if

    return p
end function

Path.change = function(new_path)
    if not new_path isa string then return TypeError.New("Path.change", "string", typeof(new_path))
    if new_path == "" then return FormatError.New("Path.New", "System path", "Empty string")

    relative = false
    if new_path[0] == "/" then
        NewPath = Path.New(new_path)
        if not NewPath then return Error.New("path.change", "Input string is invalid")
        self.slices = NewPath.slices
        return
    end if

    slices = new_path.split("/")
    for slice in slices
        if slice == ".." then
            self.slices.pop()
        else if slice == "." or slice == "" then
            continue
        else
            self.slices.push(slice)
        end if
    end for
end function

Path.path = function()
    return "/" + self.slices.join("/")
end function

Path.name = function()
    r = self.slices[-1:].join("")
    if r == "" then return "/"
    return r
end function

Path.folder = function()
    return "/" + self.slices[:-1].join("/")
end function

Path.is_parent_of = function(path)
    p = self.path
    return path[:len(p)] == p
end function



File.tree = function(recursive=false, max_depth=15, depth=0, raw=false)
    self.sanity_check
    if depth >= max_depth then return []

    if recursive != 0 and recursive != 1 then return TypeError.New("File.tree","bool", typeof(recursive))
    current = self
    result = []

    if not self.is_folder then
        current = self.parent
    end if

    if raw then
        raw_tree = function(fileob, recursive=false, max_depth=15, depth=0)
            files = []
            for f in fileob.get_files
                files.push(f)
            end for
            for d in fileob.get_folders
                files.push(d)
                if not recursive or depth == max_depth then continue
                files = files + raw_tree(d, recursive, max_depth, depth+1)

            end for
            return files
        end function

        return raw_tree(self.object, recursive, max_depth)

    else
        for x in current.get_all
            result.push(x)
            if x.is_folder and recursive and not x.is_symlink then
                result = result + x.tree(recursive, max_depth, depth+1, raw)
            end if
        end for
        return result
    end if
end function


File.find_permission = function(perms, recursive=false, first=false)
    self.sanity_check
    if not perms isa string then return TypeError.New("File.find_permission","string", typeof(perms))
    if not perms.is_match("^(?!.*(.).*\1)[rwx]{1,3}$") then return FormatError.New("File.has_permission","rwx", perms)
    if recursive != 0 and recursive != 1 then return TypeError.New("File.find_name","bool", typeof(recursive))

    result = []
    for x in self.tree(recursive, 15, 0, true)
        temp_result = true
        for p in perms
            if not x.has_permission(p) then temp_result = false
        end for
        
        if temp_result != true then continue
        if first then return File.New(x, self.root_path)
        result.push(File.New(x, self.root_path))
    end for
    return result
end function


File.find_name = function(name, recursive=false, first=false)
    self.sanity_check
    if not name isa string then return TypeError.New("File.find_name","string", typeof(name))
    if recursive != 0 and recursive != 1 then return TypeError.New("File.find_name","bool", typeof(recursive))

    result = []
    for x in self.tree(recursive,15, 0, true)
        if not x.name.is_match(name) then continue
        if first then return File.New(x, self.root_path)
        result.push(File.New(x, self.root_path))
    end for
    return result
end function


File.find_user = function(user, recursive=false, first=false)
    self.sanity_check
    if not user isa string then return TypeError.New("File.find_user","string", typeof(user))
    if recursive != 0 and recursive != 1 then return TypeError.New("File.find_user","bool", typeof(recursive))

    result = []
    for x in self.tree(recursive,15, 0, true)
        if x.owner != user then continue
        if first then return File.New(x, self.root_path)
        result.push(x)
    end for
    return result
end function


File.find_type = function(type, recursive=false, first=false)
    self.sanity_check
    if not type isa string then return TypeError.New("File.find_type","string", typeof(type))
    if recursive != 0 and recursive != 1 then return TypeError.New("File.find_type","bool", typeof(recursive))
    result = []
    for x in self.tree(recursive,15, 0, true)
        if x.is_folder and type == "folder" then
            if first then return File.New(x, self.root_path)
            result.push(File.New(x, self.root_path))
        else if x.is_binary and type == "binary" then
            if first then return File.New(x, self.root_path)
            result.push(File.New(x, self.root_path))
        else if not (x.is_folder or x.is_binary) and type == "file" then
            if first then return File.New(x, self.root_path)
            result.push(File.New(x, self.root_path))
        end if
    end for
    return result
end function


File.find_group = function(group, recursive=false, first=false)
    self.sanity_check
    if not group isa string then return TypeError.New("File.find_group","string", typeof(group))
    if recursive != 0 and recursive != 1 then return TypeError.New("File.find_group","bool", typeof(recursive))

    result = []
    for x in self.tree(recursive,15, 0, true)
        if x.group != group then continue
        if first then return File.New(x, self.root_path)
        result.push(File.New(x, self.root_path))
    end for
    return result
end function


File.get_folder = function(target)
    self.sanity_check
    p = Path.New(self.path)
    result = p.change(target)
    if is_error(result) then return result.stack("File.get_folder")
    temp = self.root_path
    if target == "/" then return File.New(temp, temp)

    for s in p.slices
        folders = temp.get_folders
        found = false
        for folder in folders 
            if folder.name.is_match("^" + s + "$") then
                temp = folder
                found = true
                break
            end if
        end for
        if not found then
            return OsError.New("File.get_folder", "Folder not found : " + target)
        end if
    end for

    return File.New(temp, self.root_path)
end function

// Backward compat
File.goto = @File.get_folder


File.get_file = function(target)
    self.sanity_check
    p = Path.New(self.path)
    p.change(target)

    folder = self.get_folder(p.folder)
    if is_error(folder) then return folder.stack("File.get_file")

    for file in folder.object.get_files
        if file.name.is_match("^"+p.name+"$") then return File.New(file, self.root_path)
    end for
    return OsError.New("File.get_file", "No file found at path : " + p.path)
end function


File.get_path = function(target)
    self.sanity_check
    p = Path.New(self.path)
    p.change(target)
    
    folder = self.get_folder(p.folder)
    if is_error(folder) then return folder.stack("File.get_file")
    if folder.object.path == target or (folder.object.path == "/" and p.slices.len == 0) then return folder

    for file in folder.object.get_files + folder.object.get_folders
        if file.name.is_match("^"+p.name+"$") then return File.New(file, self.root_path)
    end for
    return OsError.New("File.get_path", "No file found at path : " + p.path)
end function


File.get_user = function()
    self.sanity_check
    root = self.get_folder("/root")
    if is_error(root) then return root.stack("File.get_user")
    if root.has_permission("rwx") then return "root"

    home = self.get_folder("/home")
    if is_error(home) then return "unknown"
    perms = home.find_permission("rwx", true)

    if is_error(perms) then return perms.stack("File.get_user")
    for x in perms
        if x.name == ".Trash" then
            return x.owner
        end if
    end for
    return "unknown"
end function


File.in_group = function()//@returns {false|true}
    self.sanity_check
    if not self.has_permission("w") then return PermissionError.New("File.in_group","write")
    perms = self.permissions[1:]
    up = perms[0:3]
    gp = perms[3:6]
    op = perms[6:9]
    self.chmod("o-r")
    self.chmod("u-r")
    self.chmod("g+r")
    result = self.has_permission("r")
    if gp.indexOf("r") == null then self.chmod("g-r")
    if up.indexOf("r") != null then self.chmod("u+r")
    if op.indexOf("r") != null then self.chmod("o+r")
    return result
end function


File.get_user_ex = function() //@returns {map<sUser,sInGroup>|string}
    self.sanity_check
    root = File.New(self.root_path)
    file = root.find_permission("w",true,true)
    if not file then return self.get_user
    retmap = {"sUser":"", "sInGroup":""}
    eff = "o"
    prevp = file.permissions[1:]
    up = prevp[0:3]
    gp = prevp[3:6]
    op = prevp[6:9]
    permMap = {"u":up,"g":gp,"o":op}
    for f in permMap
        permMap[f.key] = f.value.replace("-", "")
    end for
    file.chmod("u-rx")
    file.chmod("g-rx")
    file.chmod("o-rx")
    file.chmod("u+w")
    file.chmod("g+wx")
    file.chmod("o+wx")
    if file.has_permission("r") then retmap.sUser = "root"
    result = self.in_group
    if result > 0 then 
        eff = "g"
        retmap.sInGroup = file.group
    end if
    users = ["root","guest"]
    home = self.get_folder("/home")
    if is_error(home) then return home.stack("File.get_user_ex")
    for user in home.get_folders
        if user.name == "guest" then continue
        users.push(user.name)
    end for

    prev = file.owner
    for user in users
        if retmap.sUser then break
	    file.set_owner(user)
	    if not file.has_permission("x") then retmap.sUser = user
    end for

    for perm in permMap
        //if perm.key=="u" then continue
        file.chmod(perm.key+"-rwx")
        file.chmod(perm.key+"+"+perm.value)
    end for
    file.chmod("u+w")
    file.chmod(eff+"+w")
    file.set_owner(prev)

    if permMap["u"].indexOf("w") == null then file.chmod("u-w")
    if permMap[eff].indexOf("w") == null then file.chmod(eff+"-w")
    return retmap
end function

File.force_chmod = function(perms, allow_get_user = true) //if allow_get_user is false then if get_user_ex fails then
    //a error is returned instead of falling back to get_user
    self.sanity_check
    if not self.has_permission("w") then return PermissionError.New("File.force_chmod","write")
    result = perms.matches("^(?:u=([rwx]{0,3})(?!.*(.).*\2)?;)?(?:g=([rwx]{0,3})(?!.*(.).*\4)?;)?(?:o=([rwx]{0,3})(?!.*(.).*\6)?;)?(?:own=[^;]+;|grp=[^;]+;).*$")
    if not result then return FormatError.New("File.force_chmod","PermissionString",typeof(perms))
    sp = perms.split(";")
    result = self.get_user_ex
    if result isa map then
        user = result.sUser
    else
        user = result
        if not allow_get_user then return KernelError.New("File.force_chmod","get_user_ex returned an error and get_user was explicitly not allowed")
    end if
    if user.lower == "unknown" or not user then return OsError.New("File.force_chmod","user is unknown, use normal chmod")
    eff = "o"
    retOwner = sp[3].split("=")[1]
    if retOwner == "" then retOwner = self.owner
    retGroup = sp[4].split("=")[1]
    if retGroup == "" then retGroup = self.group
    up = sp[0].split("=")[1]
    gp = sp[1].split("=")[1]
    op = sp[2].split("=")[1]
    permMap = {"u":up,"g":gp,"o":op}
    self.set_owner(user)    //yes user is supposed to be here not retOwner
    self.set_group(retGroup)

    result = self.in_group()
    if result > 0 then eff = "g"
    for perm in permMap
        //if perm.key=="u" then continue
        self.chmod(perm.key+"-rwx")
        self.chmod(perm.key+"+"+perm.value)
    end for
    self.chmod("u+w")
    self.chmod(eff+"+w")
    self.set_owner(retOwner)

    if permMap["u"].indexOf("w") == null then self.chmod("u-w")
    if permMap[eff].indexOf("w") == null then self.chmod(eff+"-w")
end function


// **get_effective_permissions:**
// Retrieves a list of permissions that the current user has on the file.
//
// @description **Args:**
// @param {bool} Force
// @description Force - If false, the function returns an error object when lacking write permissions. (default: true)
// @param {bool} Raw
// @description Raw - Return permissions in 'rwx' format instead o human readable strings
// @param {string} user
// @description user - do not use get_user/get_user_ex but instead the passed user
// @returns {string|Error}
// @description **Returns:** a human readable string of permissions. If access is denied and Force is false, an Error object is returned instead.
File.get_effective_permissions = function(Force = true,raw = false, user = null)
    GetWriteLevel = function(file, raw, isOwner)
        level = 0
        if file.parent.has_permission("w") then level = level + 1
        if file.has_permission("w") or isOwner then level = level + 2
        levels = ["None", "Parent", "File", "Full"]
        if raw then return level else return levels[level]
    end function


    CRE = function(perms, isOwner)
        if isOwner and perms.indexOf("w") == null then 
            perms = perms.values
            perms[1] = "w"
            perms = perms.join("")
        end if
        temp = []
        order = "rwx"
        sortedPerms = ""

        for ch in order
            if perms.indexOf(ch) != null and sortedPerms.indexOf(ch) == null then
                sortedPerms = sortedPerms + ch
            end if
        end for

        for perm in sortedPerms
            if raw then
                temp.push(perm)
                continue
            end if
            if perm == "r" then temp.push("read")
            if perm == "w" then temp.push("write")
            if perm == "x" then temp.push("execute")
        end for
        if raw then return temp.join("") else return temp.join(", ")
    end function

    effperms = ""
    eff = null
    if not user then user = self.get_user_ex
    isown = user == self.owner
    ingrp = self.in_group
    if is_error(ingrp) and not Force then return ingrp.stack("File.get_effective_permissions")
    if self.has_permission("r") then effperms = effperms + "r" else effperms = effperms + "-" //({"raw":"r", "eval":"read"})
    if self.has_permission("w") or self.parent.has_permission("w") then effperms = effperms + "w" else effperms = effperms + "-"//({"raw":"w", "eval":"write"})
    if self.has_permission("x") then effperms = effperms + "x" else effperms = effperms + "-"//({"raw":"x", "eval":"execute"})
    prevp = self.permissions[1:]
    up = prevp[0:3]
    gp = prevp[3:6]
    op = prevp[6:9]
    permMap = {"u":up,"g":gp,"o":op}
    for f in permMap
        if f.value == effperms then eff = f.key
    end for
    StringPerms = CRE(effperms, isown)
    if raw then 
        offset = 1
        idx = StringPerms.indexOf("w")
    else 
        offset = 5
        idx = StringPerms.indexOf("write")
    end if
    writelvl = GetWriteLevel(self, raw, isown)
    if idx != null then
        StringPerms = StringPerms.insert(idx + offset, "(" + GetWriteLevel(self, raw, isown) + ")")
    end if

    if StringPerms == "" then StringPerms = "none"
    if user isa map then user = user.sUser
    if (user.lower == "unknown" or not user) then return StringPerms+":"+eff
    if user == self.owner then return StringPerms+":u"
    if ingrp == 1 then return StringPerms+":g"
    return StringPerms+":o"
end function

File.get_permission = function()
    self.sanity_check
    uname = self.get_user()
    if is_error(uname) then return uname
    if ["guest","root","unknown"].indexOf(uname) != null then return uname
    return "user"
end function

File.get_all = function()
    self.sanity_check
    if not self.is_folder then return TypeError.New("File.get_all","folder", self.file_type)

    result = []
    for item in (self.object.get_folders + self.object.get_files)
        result.push(File.New(item, self.root_path))
    end for

    return result
end function

File.create_folder = function(path,name)
    self.sanity_check
    target = self.get_folder(path)
    if is_error(target) then return target.stack("File.create_folder")
    if not target.has_permission("w") then return PermissionError.New("File.create_folder","write")
    folder = self.get_folder("/")
    if is_error(folder) then return folder.stack("File.create_folder")
    folders = self.find_type("folder",true)
    selected = null
    for fold in folders
        if fold.has_permission("r") then 
            selected = fold
            break
        end if
    end for
    if selected == null then return OsError.New("File.create_folder","readable folder not found")
    result = selected.copy(path,name)
    if is_error(result) then return result.stack("File.create_folder")
    newfold = folder.get_path(path+"/"+name)
    files = newfold.get_files + newfold.get_folders
    for file in files
        result = file.silent_rm()
        if is_error(result) then return result.stack("File.create_folder")
    end for
    return newfold
end function

File.silent_rm = function() //@returns {Error|true}
    self.sanity_check
    if self.path == "/" then return OsError.New("File.delete","file '/' cannot be deleted")
    if not self.parent.has_permission("w") then return PermissionError.New("File.silent_rm","write")
    if self.is_folder and not self.is_symlink then
        self.move(self.path,"anyname")
        return 1
    end if
    root = self.get_folder("/")
    if is_error(root) then return root
    files = root.find_type("file", true)
    target = null
    for file in files
        if target != null then break
        if file.parent.has_permission("w") and self.path != file.path then target = file
    end for
    if target == null then return OsError.New("File.silent_rm","no movable file found")
    prevp = target.path
    prevn = target.name
    result = target.move(parent_path(self.path),self.name)
    if is_error(result) then return result.stack("File.silent_rm")
    result = target.move(parent_path(prevp),prevn)
    if is_error(result) then return result.stack("File.silent_rm")
    return 1
end function

File.touch = function(path, name)
    self.sanity_check
    folder = self.get_folder("/")
    if is_error(folder) then return folder.stack("File.touch")
    files = self.find_type("file",true)
    selected = null
    for file in files
        if file.has_permission("r") then 
            selected = file
            break
        end if
    end for
    if selected == null then return OsError.New("File.touch","readable file not found")
    result = selected.copy(path,name)
    if is_error(result) then return result.stack("File.touch")
    newfile = folder.get_path(path+"/"+name)
    if is_error(newfile) then return newfile.stack("File.touch")
    result = newfile.set_content("")
    if is_error(result) then return result.stack("File.touch")
    return newfile
end function



Computer.get_user = function()
    all_files = self.File("/").tree(true, 15, 0, true)
    selected = null

    for f in all_files
        if not f.is_folder then continue
        if not f.has_permission("w") then continue
        selected = f
        break
    end for

    if selected == null then return "unknown"

    self.touch(selected.path, "Sources.txt")
    check = self.File(selected.path + "/Sources.txt")

    if is_error(check) then return "unknown"
    return check.owner
end function

Computer.get_permission = function()
    uname = self.get_user()
    if is_error(uname) then return uname
    if ["guest","root","unknown"].indexOf(uname) != null then return uname
    return "user"
end function

Shell.get_user = function()
    return self.host_computer.get_user
end function

Shell.get_permission = function()
    uname = self.get_user()
    if is_error(uname) then return uname
    if ["guest","root","unknown"].indexOf(uname) != null then return uname
    return "user"
end function