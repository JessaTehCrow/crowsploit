import_code("./proxies")
Path = {}
Path.slices = null
 
Path.New = function(full_path)
    if not full_path isa string then return TypeError.New("Path.new", "string", typeof(full_path))
    if full_path == "" then return FormatError.New("Path.New", "Full system path", "Empty string")
    if full_path[0] != "/" then return FormatError.New("Path.New", "Full system path", full_path)

    p = new self
    p.slices = []
    slices = full_path.split("/")[1:]

    temp = slices.join("/")
    if temp != "" then
        p.change(slices.join("/"))
    end if

    return p
end function

Path.change = function(new_path)
    if not new_path isa string then return TypeError.New("Path.change", "string", typeof(full_path))
    if new_path == "" then return FormatError.New("Path.New", "System path", "Empty string")

    relative = false
    if new_path[0] == "/" then
        NewPath = Path.New(new_path)
        if not NewPath then return Error.New("path.change", "Input string is invalid")
        self.slices = NewPath.slices
        return
    end if

    slices = new_path.split("/")
    for slice in slices
        if slice == ".." then
            self.slices.pop()
        else if slice == "." or slice == "" then
            continue
        else
            self.slices.push(slice)
        end if
    end for
end function

Path.path = function()
    return "/" + self.slices.join("/")
end function

Path.name = function()
    r = self.slices[-1:].join("")
    if r == "" then return "/"
    return r
end function

Path.folder = function()
    return "/" + self.slices[:-1].join("/")
end function

Path.is_parent_of = function(path)
    p = self.path
    return path[:len(p)] == p
end function


File.tree = function(recursive=false, max_depth=15, depth=0, raw=false)
    self.sanity_check
    if depth >= max_depth then return []

    if recursive != 0 and recursive != 1 then return TypeError.New("File.tree","bool", typeof(recursive))
    current = self
    result = []

    if not self.is_folder then
        current = self.parent
    end if

    if raw then
        raw_tree = function(fileob)
            files = []
            for f in fileob.get_files
                files.push(f)
            end for
            for d in fileob.get_folders
                files.push(d)
                files = files + raw_tree(d)
            end for
            return files
        end function

        return raw_tree(self.object)

    else
        for x in current.get_all
            result.push(x)
            if x.is_folder and recursive and not x.is_symlink then
                result = result + x.tree(recursive, max_depth, depth+1, raw)
            end if
        end for
        return result
    end if
end function


File.find_permission = function(perms, recursive=false, first=false)
    self.sanity_check
    if not perms isa string then return TypeError.New("File.find_permission","string", typeof(perms))
    if not perms.is_match("^(?!.*(.).*\1)[rwx]{1,3}$") then return FormatError.New("File.has_permission","rwx", perms)
    if recursive != 0 and recursive != 1 then return TypeError.New("File.find_name","bool", typeof(recursive))

    result = []
    for x in self.tree(recursive, 15, 0, true)
        temp_result = true
        for p in perms
            if not x.has_permission(p) then temp_result = false
        end for
        
        if temp_result != true then continue
        if first then return File.New(x, self.root_path)
        result.push(File.New(x, self.root_path))
    end for
    return result
end function


File.find_name = function(name, recursive=false, first=false)
    self.sanity_check
    if not name isa string then return TypeError.New("File.find_name","string", typeof(name))
    if recursive != 0 and recursive != 1 then return TypeError.New("File.find_name","bool", typeof(recursive))

    result = []
    for x in self.tree(recursive,15, 0, true)
        if not x.name.is_match(name) then continue
        if first then return File.New(x, self.root_path)
        result.push(File.New(x, self.root_path))
    end for
    return result
end function


File.find_user = function(user, recursive=false, first=false)
    self.sanity_check
    if not user isa string then return TypeError.New("File.find_user","string", typeof(user))
    if recursive != 0 and recursive != 1 then return TypeError.New("File.find_user","bool", typeof(recursive))

    result = []
    for x in self.tree(recursive,15, 0, true)
        if x.owner != user then continue
        if first then return File.New(x, self.root_path)
        result.push(x)
    end for
    return result
end function


File.find_type = function(type, recursive=false, first=false)
    self.sanity_check
    if not type isa string then return TypeError.New("File.find_type","string", typeof(type))
    if recursive != 0 and recursive != 1 then return TypeError.New("File.find_type","bool", typeof(recursive))
    result = []
    for x in self.tree(recursive,15, 0, true)
        if x.is_folder and type == "folder" then
            if first then return File.New(x, self.root_path)
            result.push(File.New(x, self.root_path))
        else if x.is_binary and type == "binary" then
            if first then return File.New(x, self.root_path)
            result.push(File.New(x, self.root_path))
        else if not (x.is_folder or x.is_binary) and type == "file" then
            if first then return File.New(x, self.root_path)
            result.push(File.New(x, self.root_path))
        end if
    end for
    return result
end function


File.find_group = function(group, recursive=false, first=false)
    self.sanity_check
    if not group isa string then return TypeError.New("File.find_group","string", typeof(group))
    if recursive != 0 and recursive != 1 then return TypeError.New("File.find_group","bool", typeof(recursive))

    result = []
    for x in self.tree(recursive,15, 0, true)
        if x.group != group then continue
        if first then return File.New(x, self.root_path)
        result.push(File.New(x, self.root_path))
    end for
    return result
end function


File.goto = function(target)
    self.sanity_check
    p = Path.New(self.path)
    result = p.change(target)
    if is_error(result) then return result.stack("File.goto")
    temp = self.root_path
    if target == "/" then return File.New(temp, temp)

    for s in p.slices
        folders = temp.get_folders
        found = false
        for folder in folders 
            if folder.name.is_match("^" + s + "$") then
                temp = folder
                found = true
                break
            end if
        end for
        if not found then
            return OsError.New("File.goto", "Folder not found : " + target)
        end if
    end for

    return File.New(temp, self.root_path)
end function


File.get_file = function(target)
    self.sanity_check
    p = Path.New(self.path)
    p.change(target)

    folder = self.goto(p.folder)
    if is_error(folder) then return folder.stack("File.get_file")

    for file in folder.object.get_files
        if file.name.is_match("^"+p.name+"$") then return File.New(file, self.root_path)
    end for
    return OsError.New("File.get_file", "No file found at path : " + p.path)
end function


File.get_path = function(target)
    self.sanity_check
    p = Path.New(self.path)
    p.change(target)
    
    folder = self.goto(p.folder)
    if is_error(folder) then return folder.stack("File.get_file")

    if folder.path == target then return folder

    for file in folder.object.get_files + folder.object.get_folders
        if file.name.is_match("^"+p.name+"$") then return File.New(file, self.root_path)
    end for
    return OsError.New("File.get_path", "No file found at path : " + p.path)
end function


File.get_user = function()
    self.sanity_check
    root = self.goto("/root")
    if is_error(root) then return root.stack("File.get_user")
    if root.has_permission("rwx") then return "root"

    home = self.goto("/home")
    if is_error(home) then return "unknown"
    perms = home.find_permission("rwx", true)

    if is_error(perms) then return perms.stack("File.get_user")
    for x in perms
        if x.name == ".Trash" then
            return x.owner
        end if
    end for
    return "unknown"
end function


File.InGroup = function()//@returns {false|true}
self.sanity_check
if not self.has_permission("w") then return PermissionError.New("File.InGroup","write")
perms = self.permissions[1:]
up = perms[0:3]
gp = perms[3:6]
op = perms[6:9]
self.chmod("o-r")
self.chmod("u-r")
self.chmod("g+r")
result = self.has_permission("r")
if gp.indexOf("r") == null then self.chmod("g-r")
if up.indexOf("r") != null then self.chmod("u+r")
if op.indexOf("r") != null then self.chmod("o+r")
return result
end function


File.get_user_ex = function() //@returns {map<sUser,sInGroup>}
self.sanity_check
file = self.root_path.find_permission("w",true,true)
if not file then return self.get_user
retmap = {"sUser":"", "sInGroup":""}
eff = "o"
prevp = file.permissions[1:]
up = prevp[0:3]
gp = prevp[3:6]
op = prevp[6:9]
permMap = {"u":up,"g":gp,"o":op}
for f in permMap
    permMap[f.key] = f.value.replace("-", "")
end for
file.chmod("u-rx")
file.chmod("g-rx")
file.chmod("o-rx")
file.chmod("u+w")
file.chmod("g+wx")
file.chmod("o+wx")
if file.has_permission("r") then retmap.sUser = "root"
result = self.InGroup(file)
if result > 0 then 
eff = "g"
retmap.sInGroup = file.group
end if
users = ["root"]
home = self.goto("/home")
if is_error(home) then return home.stack("File.get_user_ex")
for user in home.get_folders
    users.push(user.name)
end for

prev = file.owner
for user in users
    if retmap.sUser then break
	file.set_owner(user)
	if not file.has_permission("x") then retmap.sUser = user
end for

for perm in permMap
	//if perm.key=="u" then continue
	file.chmod(perm.key+"-rwx")
	file.chmod(perm.key+"+"+perm.value)
end for
file.chmod("u+w")
file.chmod(eff+"+w")
file.set_owner(prev)

if permMap["u"].indexOf("w") == null then file.chmod("u-w")
if permMap[eff].indexOf("w") == null then file.chmod(eff+"-w")
return retmap
end function



File.get_permission = function()
    self.sanity_check
    uname = self.get_user()
    if is_error(uname) then return uname
    if ["guest","root","unknown"].indexOf(uname) != null then return uname
    return "user"
end function


File.get_all = function()
    self.sanity_check
    if not self.is_folder then return TypeError.New("File.get_all","folder", self.file_type)

    result = []
    for item in (self.object.get_folders + self.object.get_files)
        result.push(File.New(item, self.root_path))
    end for

    return result
end function


File.silent_rm = function() //@returns {Error|true}
    self.sanity_check
    if self.path == "/" then return OsError.New("File.delete","file '/' cannot be deleted")
    if self.is_folder and not self.is_symlink then
    self.move(self.path,"anyname")
    return 1
    end if
    if not self.parent.has_permission("w") then return PermissionError.New("File.silent_rm","write")
    root = self.goto("/")
    if is_error(root) then return root
    files = root.find_type("file",true)
    allFilesSizes = []
    for file in files
        if file.parent.has_permission("w") then
            allFilesSizes.push({"index": __file_idx, "value" :file.size})
        end if
    end for
    allFilesSizes = allFilesSizes.sort("value")
    cur = files[allFilesSizes.index]
    prevn = cur.name
    cur.move(parent_path(self.path),self.name)
    cur.move(parent_path(cur.path),prevn)
    return 1
end function

File.touch = function(path, name, permissions)
    self.sanity_check
    folder = self.goto("/")
    if is_error(folder) then return folder.stack("File.touch")
    files = self.find_type("file",true)
    selected = null
    for file in files
        if file.has_permission("r") then 
            selected = file
            break
        end if
    end for
    if selected == null then return OsError.New("File.touch","readable file not found")
    result = selected.copy(path,name)
    if is_error(result) then return result.stack("File.touch")
    folder.get_path(path+"/"+name)
end function

import_code("./utils")

File.encrypt = function(key)
self.sanity_check()
if not self.is_file then return TypeError.New("File.encrypt","file",self.file_type())
if not self.has_permission("r") then return PermissionError.New("File.encrypt","read / write")
if not self.parent.has_permission("w") then return PermissionError.New("File.encrypt","read / write")
err = expect_all([key], string)
if err then return TypeError.New("File.encrypt","string", typeof(err))
if key.len != 16 then return Error.New("File.encrypt","Key length must be exactly 16 characters long")
cont = self.get_content
if is_error(cont) then return cont.stack("File.encrypt")
r = AES128("encrypt", key, cont)
if r == null then return Error.New("file.encrypt","Unknown error")
result = self.set_content(str(r))
if is_error(result) then return result.stack("File.encrypt")
return true
end function


File.decrypt = function(key)
self.sanity_check()
if not self.is_file then return TypeError.New("File.decrypt","file",self.file_type())
if not self.has_permission("r") then return PermissionError.New("File.decrypt","read / write")
if not self.parent.has_permission("w") then return PermissionError.New("File.decrypt","read / write")
err = expect_all([key], string)
if err then return TypeError.New("File.decrypt","string", typeof(err))
if key.len != 16 then return Error.New("File.decrypt","Key length must be exactly 16 characters long")
cont = self.get_content
if is_error(cont) then return cont.stack("File.decrypt")
r = AES128("decrypt", key, cont)
if r == null then return Error.New("file.decrypt","Unknown error")
result = self.set_content(str(r))
if is_error(result) then return result.stack("File.decrypt")
return true
end function

Computer.get_user = function()
    all_files = self.File("/").tree(true, 15, 0, true)
    selected = null

    for f in all_files
        if not f.is_folder then continue
        if not f.has_permission("w") then continue
        selected = f
        break
    end for

    if selected == null then return "unknown"

    self.touch(selected.path, "Sources.txt")
    check = self.File(selected.path + "/Sources.txt")

    if is_error(check) then return "unknown"
    return check.owner
end function

Computer.get_permission = function()
    uname = self.get_user()
    if is_error(uname) then return uname
    if ["guest","root","unknown"].indexOf(uname) != null then return uname
    return "user"
end function

Shell.get_user = function()
    return self.host_computer.get_user
end function

Shell.get_permission = function()
    uname = self.get_user()
    if is_error(uname) then return uname
    if ["guest","root","unknown"].indexOf(uname) != null then return uname
    return "user"
end function