import_code("./proxies")

Path = {}
Path.slices = null
 
Path.New = function(full_path)
    if not full_path isa string then return TypeError.New("Path.new", "string", typeof(full_path))
    if full_path == "" then return FormatError.New("Path.New", "Full system path", "Empty string")
    if full_path[0] != "/" then return FormatError.New("Path.New", "Full system path", full_path)

    p = new self
    p.slices = []
    slices = full_path.split("/")[1:]

    temp = slices.join("/")
    if temp != "" then
        p.change(slices.join("/"))
    end if

    return p
end function

Path.change = function(new_path)
    if not new_path isa string then return TypeError.New("Path.change", "string", typeof(full_path))
    if new_path == "" then return FormatError.New("Path.New", "System path", "Empty string")

    relative = false
    if new_path[0] == "/" then
        NewPath = Path.New(new_path)
        if not NewPath then return Error.New("path.change", "Input string is invalid")
        self.slices = NewPath.slices
        return
    end if

    slices = new_path.split("/")
    for slice in slices
        if slice == ".." then
            self.slices.pop()
        else if slice == "." or slice == "" then
            continue
        else
            self.slices.push(slice)
        end if
    end for
end function

Path.path = function()
    return "/" + self.slices.join("/")
end function

Path.name = function()
    r = self.slices[-1:].join("")
    if r == "" then return "/"
    return r
end function

Path.folder = function()
    return "/" + self.slices[:-1].join("/")
end function

Path.is_parent_of = function(path)
    p = self.path
    return path[:len(p)] == p
end function


File.tree = function(recursive=false, max_depth=15, depth=0, raw=false)
    self.sanity_check
    if depth >= max_depth then return []

    if recursive != 0 and recursive != 1 then return TypeError.New("File.tree","bool", typeof(recursive))
    current = self
    result = []

    if not self.is_folder then
        current = self.parent
    end if

    if raw then
        raw_tree = function(fileob)
            files = []
            for f in fileob.get_files
                files.push(f)
            end for
            for d in fileob.get_folders
                files.push(d)
                files = files + raw_tree(d)
            end for
            return files
        end function

        return raw_tree(self.object)

    else
        for x in current.get_all
            result.push(x)
            if x.is_folder and recursive and not x.is_symlink then
                result = result + x.tree(recursive, max_depth, depth+1, raw)
            end if
        end for
        return result
    end if
end function


File.find_permission = function(perms, recursive=false, first=false)
    self.sanity_check
    if not perms isa string then return TypeError.New("File.find_permission","string", typeof(perms))
    if not perms.is_match("^(?!.*(.).*\1)[rwx]{1,3}$") then return FormatError.New("File.has_permission","rwx", perms)
    if recursive != 0 and recursive != 1 then return TypeError.New("File.find_name","bool", typeof(recursive))

    result = []
    for x in self.tree(recursive, 15, 0, true)
        temp_result = true
        for p in perms
            if not x.has_permission(p) then temp_result = false
        end for
        
        if temp_result != true then continue
        if first then return File.New(x, self.root_path)
        result.push(File.New(x, self.root_path))
    end for
    return result
end function


File.find_name = function(name, recursive=false, first=false)
    self.sanity_check
    if not name isa string then return TypeError.New("File.find_name","string", typeof(name))
    if recursive != 0 and recursive != 1 then return TypeError.New("File.find_name","bool", typeof(recursive))

    result = []
    for x in self.tree(recursive,15, 0, true)
        if not x.name.is_match(name) then continue
        if first then return File.New(x, self.root_path)
        result.push(File.New(x, self.root_path))
    end for
    return result
end function


File.find_user = function(user, recursive=false, first=false)
    self.sanity_check
    if not user isa string then return TypeError.New("File.find_user","string", typeof(user))
    if recursive != 0 and recursive != 1 then return TypeError.New("File.find_user","bool", typeof(recursive))

    result = []
    for x in self.tree(recursive,15, 0, true)
        if x.owner != user then continue
        if first then return File.New(x, self.root_path)
        result.push(x)
    end for
    return result
end function


File.find_type = function(type, recursive=false, first=false)
    self.sanity_check
    if not type isa string then return TypeError.New("File.find_type","string", typeof(type))
    if recursive != 0 and recursive != 1 then return TypeError.New("File.find_type","bool", typeof(recursive))
    result = []
    for x in self.tree(recursive,15, 0, true)
        if x.is_folder and type == "folder" then
            if first then return File.New(x, self.root_path)
            result.push(File.New(x, self.root_path))
        else if x.is_binary and type == "binary" then
            if first then return File.New(x, self.root_path)
            result.push(File.New(x, self.root_path))
        else if x.is_file and type == "file" then
            if first then return File.New(x, self.root_path)
            result.push(File.New(x, self.root_path))
        end if
    end for
    return result
end function


File.find_group = function(group, recursive=false, first=false)
    self.sanity_check
    if not group isa string then return TypeError.New("File.find_group","string", typeof(group))
    if recursive != 0 and recursive != 1 then return TypeError.New("File.find_group","bool", typeof(recursive))

    result = []
    for x in self.tree(recursive,15, 0, true)
        if x.group != group then continue
        if first then return File.New(x, self.root_path)
        result.push(File.New(x, self.root_path))
    end for
    return result
end function


File.goto = function(target)
    self.sanity_check
    p = Path.New(self.path)
    result = p.change(target)
    if is_error(result) then return result.stack("File.goto")
    temp = self.root_path
    if target == "/" then return File.New(temp, temp)

    for s in p.slices
        folders = temp.get_folders
        found = false
        for folder in folders 
            if folder.name.is_match("^" + s + "$") then
                temp = folder
                found = true
                break
            end if
        end for
        if not found then
            return OsError.New("File.goto", "Folder not found : " + target)
        end if
    end for

    return File.New(temp, self.root_path)
end function


File.get_file = function(target)
    self.sanity_check
    p = Path.New(self.path)
    p.change(target)

    folder = self.goto(p.folder)
    if is_error(folder) then return folder.stack("File.get_file")

    for file in folder.object.get_files
        if file.name.is_match("^"+p.name+"$") then return File.New(file, self.root_path)
    end for
    return OsError.New("File.get_file", "No file found at path : " + p.path)
end function


File.get_path = function(target)
    self.sanity_check
    p = Path.New(self.path)
    p.change(target)
    
    folder = self.goto(p.folder)
    if is_error(folder) then return folder.stack("File.get_file")

    if folder.path == target then return folder

    for file in folder.object.get_files + folder.object.get_folders
        if file.name.is_match("^"+p.name+"$") then return File.New(file, self.root_path)
    end for
    return OsError.New("File.get_path", "No file found at path : " + p.path)
end function


File.get_user = function()
    self.sanity_check
    root = self.goto("/root")
    if is_error(root) then return root.stack("File.get_user")
    if root.has_permission("rwx") then return "root"

    home = self.goto("/home")
    if is_error(home) then return "unknown"
    perms = home.find_permission("rwx", true)

    if is_error(perms) then return perms.stack("File.get_user")
    for x in perms
        if x.name == ".Trash" then
            return x.owner
        end if
    end for
    return "unknown"
end function


File.get_permission = function()
    self.sanity_check
    uname = self.get_user()
    if is_error(uname) then return uname
    if ["guest","root","unknown"].indexOf(uname) != null then return uname
    return "user"
end function


File.get_all = function()
    self.sanity_check
    if not self.is_folder then return TypeError.New("File.get_all","folder", self.file_type)

    result = []
    for item in (self.object.get_folders + self.object.get_files)
        result.push(File.New(item, self.root_path))
    end for

    return result
end function


File.slient_rm = function() //returns error | true
    self.sanity_check

    if self.is_folder and not self.is_symlink then
    self.move(self.path,"anyname")
    return 1
    end if
    root = self.goto("/")
    if is_error(root) then return root
    folders = root.find_type("folder",true)
    readfold = null
    writefold = null
    samefold = false
    allFolderSizes = []
    for folder in folders
        if folder.has_permission("rw") then
            allFolderSizes.push({"index": __folder_idx, "value" :folder.size})
            samefold = true
        end if
    end for

    if samefold == false then

        for folder in folders
            if writefold == null and folder.has_permission("w") then writefold = folder
            if folder.has_permission("r") then allFolderSizes.push({"index": __folder_idx, "value" :folder.size})
        end for

    end if

    allFolderSizes = allFolderSizes.sort("value")

    if allFolderSizes.len == 0 then return OsError.New("File.slient_rm", "Cannot find readable folder to copy")
    
    
    if samefold then
        writefold = folders[allFolderSizes[0].index]
    
    end if

    if writefold == null then return OsError.New("File.slient_rm", "Cannot find writable folder to copy into")
    readfold = folders[allFolderSizes[0].index]

    readfold.copy(writefold.path,"lolpath101")
    if not readfold.has_permission("w") then
    curown = writefold.owner
    writefold.set_owner(self.get_user(),true)
    end if
    readfold = self.goto(writefold.path+"/lolpath101")
    self.move(writefold.path+"/lolpath101",self.name)
    readfold.move(readfold.path,readfold.name)
    return 1
end function


Computer.get_user = function()
    all_files = self.File("/").tree(true, 15, 0, true)
    selected = null

    for f in all_files
        if not f.is_folder then continue
        if not f.has_permission("w") then continue
        selected = f
        break
    end for

    if selected == null then return "unknown"

    self.touch(selected.path, "Sources.txt")
    check = self.File(selected.path + "/Sources.txt")

    if is_error(check) then return "unknown"
    return check.owner
end function

Computer.get_permission = function()
    uname = self.get_user()
    if is_error(uname) then return uname
    if ["guest","root","unknown"].indexOf(uname) != null then return uname
    return "user"
end function

Shell.get_user = function()
    return self.host_computer.get_user
end function

Shell.get_permission = function()
    uname = self.get_user()
    if is_error(uname) then return uname
    if ["guest","root","unknown"].indexOf(uname) != null then return uname
    return "user"
end function