import_code("../libs/proxyextension")

string_gen = function(chars, length)
    result = ""
    for x in range(length)
        result = result + chars[floor(rnd * len(chars))]
    end for
    return result
end function

isalnum = function(text)
    return text.is_match("^[A-Za-z0-9._-]+$")
end function

regex_escape = function(text)
    result = text

    for x in "+*?^$.[]{}()|/"
        result = result.replace("\"+x, "\"+x)
    end for

    return result
end function


parse_ip = function(value)
    if value.is_match("(www\.)?\w+\.(org|net|com|info)") then
        result = null
        if value[:4] != "www." then
            result = nslookup("www."+value)
        else
            result = nslookup(value)
        end if
        if result != "IP not found" then return result
        return ParseError.New("Command.parse_args", "Domain doesn't exist : " + value)

    else if is_valid_ip(value) then
        if not is_valid_ip_range(value) then return ParseError.New("Command.parse_args", "Invalid ip range : " + value)
        return value
    end if

    return ParseError.New("Command.parse_args", "Invalid ip/host specified : " + value)
end function


select_index = function(msg, indexes)
    if not indexes isa number then return TypeError.New("exploit.select_index", "number", typeof(indexes))
    result = null

    while result == null
        print(msg)
        inp = user_input(_global.kernel.color("$P;" + "Select index between $S;1$P; and $S;"+indexes + char(10) + "$S;: $T2;"))
        val = to_int(inp)
        if inp == "" then
            break
        else if typeof(val) != "number" then 
            print("<#e88>Invalid input")
        else if val < 1 or val > indexes then
            print("<#e88>Option out of range")
        else
            result = val-1
        end if
    end while

    return result
end function


create_permission_string = function(ownerPerms, groupPerms, otherPerms, owner, group)
    err = expect_all([ownerPerms, groupPerms, otherPerms, owner, group], string)
    if err then return TypeError.New("string", typeof(err))

    for f in [ownerPerms, groupPerms, otherPerms]
        if not f.is_match("^(|(?!.*(.).*\1)[rwx]{0,3})$") then return FormatError.New("File.set_permission","[rwx]")
    end for

    retstr = ""

    for field in [ownerPerms, groupPerms, otherPerms, owner, group]
        pre = ["u","g","o","own","grp"][__field_idx]
        retstr = retstr + pre + "=" + field + ";"
    end for
    
    return retstr
end function

count = function(text, substr)
    err = expect_all([text, substr], string)
    if err then return TypeError.New("string", typeof(err))
    return text.matches(substr).len
end function


string.count = function(substr)
    return count(self, substr)
end function


map_list = function(arr, func)
    if not func isa list and not typeof(func) == "function" then return TypeError.New("map_list","func | list[func]", typeof(func))

    funcs = func
    if typeof(func) == "function" then funcs = [func]

    result = []
    for item in arr
        temp = item

        for f in funcs
            if typeof(@f) != "function" then return TypeError.New("map_list", "func", typeof(@f))
            temp = f(temp)
        end for
        result.push(temp)
    end for

    return result
end function


min = function(a,b)
    if not a isa number and not a isa list then return TypeError.New("min","number | list", typeof(a))
    if a isa number and not b isa number then return TypeError.New("number", typeof(b))
    
    if a isa number then return [a,b][a>b]

    smallest = null

    for item in a
        if not item isa number then return TypeError.New("min","list[number]", typeof(item))
        if smallest == null then smallest = item
        smallest = min(smallest, item)
    end for
    
    return smallest
end function


max = function(a,b)
    if not a isa number and not a isa list then return TypeError.New("max","number | list", typeof(a))
    if a isa number and not b isa number then return TypeError.New("max","number", typeof(b))
    
    if a isa number then return [a,b][a<b]
    biggest = null

    for item in a
        if not item isa number then return TypeError.New("max","list[number]", typeof(item))
        if biggest == null then biggest = item
        biggest = max(biggest, item)
    end for

    return biggest
end function


to_title = function(text)
    t = text.split(" ")
    for x in t
        if x == "" then continue
        t[__x_idx] = x[0].upper() + x[1:]
    end for
    return t.join(" ")
end function


simple_hash = function(text)
    chars = "AaBbCcDdEeFfGgHhJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789"
    hash_val = md5(text)
    result = ""
    
    for x in text
        seed = code(hash_val[__x_idx%hash_val.len]) + code(x) + __x_idx + chars.len
        result = result + chars[seed%chars.len]
    end for
    return result
end function


uncolor_string = function(text)
    if not text isa string then return TypeError.New("uncolor_string","string", typeof(text))
    tags = [
        "align",
        "alpha",
        "color",
        "b",
        "i",
        "cspace",
        "font",
        "indent",
        "line-height",
        "line-indent",
        "link",
        "lowercase",
        "uppercase",
        "smallcaps",
        "margin",
        "mark",
        "mspace",
        "noparse",
        "nobr",
        "page",
        "pos",
        "size",
        "space",
        "sprite",
        "s",
        "br",
        "u",
        "style",
        "sub",
        "sup",
        "voffset",
        "width",
        "link",
        "#[0-9a-fA-F]{3}",
        "#[0-9a-fA-F]{6}",
        "#[0-9a-fA-F]{8}",
    ]

    new_value = text
    joined = tags.join("|")
    results = new_value.matches("<\/?("+joined+")(\s.*?|=.*?|.{0})>")
    for r in results
        new_value = new_value.replace(r.value, r.value.insert(1, "<sup></sup>"))
    end for
    //new_value = new_value.replace("<\/?("+joined+")(\s.*?|=.*?|.{0})>", "")
    return new_value
end function


unformat_string = function(text)
    if not text isa string then return TypeError.New("unformat_string","string", typeof(text))

    tags = [
        "align",
        "alpha",
        "color",
        "b",
        "i",
        "cspace",
        "font",
        "indent",
        "line-height",
        "line-indent",
        "link",
        "br",
        "lowercase",
        "uppercase",
        "smallcaps",
        "margin",
        "mark",
        "mspace",
        "noparse",
        "nobr",
        "page",
        "pos",
        "size",
        "space",
        "sprite",
        "s",
        "u",
        "style",
        "sub",
        "sup",
        "voffset",
        "width",
        "link",
        "#[0-9a-fA-F]{3}",
        "#[0-9a-fA-F]{6}",
    ]

    new_value = text
    joined = tags.join("|")
    new_value = new_value.replace("<\/?("+joined+")(\s.*?|=.*?|.{0})>", "")
    
    return new_value
end function


tabulate_data = function(data, titles, data_colors, title_colors, spaces=3)
    // Type checking
    if not data isa list then return TypeError.New("tabulate_data","list[list[any]]", typeof(data))
    err = expect_all(data, list)
    if err != null then return TypeError.New("tabulate_data","list[any]", typeof(err))

    // Defaults
    if data_colors == null then data_colors = ["<#ddd>"]
    if title_colors == null then title_colors = ["<i><#669>"]

    result = {}
    result.string = null
    result.longest = null
    result.lines = []

    // Tabulator extra functions
    get_line = function(items, lengths, colors)
        result = ""
        for item in items
            col = colors[__item_idx%colors.len]
            value = str(item)
            local_spaces = lengths[__item_idx] - unformat_string(value).len
            result = result + col + value + " "*(local_spaces+spaces)
        end for
        return result
    end function

    // Tabulator
    longest = []
    for title in titles 
        longest.push(len(title))
    end for

    // find longest line
    for items in data
        for item in items
            if __item_idx >= titles.len then break
            longest[__item_idx] = max(longest[__item_idx], unformat_string(str(item)).len)
        end for
    end for

    result.lines.push(get_line(titles, longest, title_colors))
    for item in data
        result.lines.push(get_line(item, longest, data_colors))
    end for
    
    result.length = unformat_string(result.lines[0]).len
    result.string = result.lines.join(char(10))
    return result
end function


globals_to_locals = function(local, global)
    for x in global
        local[x.key] = @x.value
    end for
end function


bin_to_int = function(bin)
    result = 0

    base = len(bin)
    for x in bin
        result = result + (2*to_int(x)) ^ base / 2
        base = base - 1
    end for
    return result
end function


int_to_bin = function(val)
    result = []

    i = 0
    while val > 0
        result.insert(0, val % 2)
        val = floor(val / 2)
        i = i + 1
    end while

    return result.join("")
end function


hex_chars = "0123456789abcdef"
int_to_hex = function(val, padding=0)
    result = []
    
    i = 0
    while val > 0
        result.insert(0, hex_chars[val % 16])
        val = floor(val/16)
        i = i + 1
    end while

    result = result.join("")
    result = "0"*(padding-len(result))+result
    return result
end function


hex_to_int = function(hex)
    result = 0
    
    base = len(hex)-1
    for c in hex.lower()
        result = result + (indexOf(hex_chars, c) * (16^base))
        base = base - 1
    end for

    return result
end function

random = function(min, max, float=false)
    err = expect_all([min, max], number)
    if err != null then return TypeError.New("utils.random", "int", typeof(err))
    if max < min then return ValueError.New("utils.random", "Min must be smaller than max")

    result = min + rnd * (max-min)
    if float then return result
    return round(result)
end function

rainbowify = function(str)
	if not str isa string then return null
    hexColor = function(n, d = 0)
        cs = "0123456789abcdef"
        c = 1
        x = (1 - abs((n / 60) % 2 - 1))
        m = 0
        l = [0, 0, 0]
        if 0 <= n and n < 60 then
            l = [c, x, 0]
        else if 60 <= n and n < 120 then
            l = [x, c, 0]
        else if 120 <= n and n < 180 then
            l = [0, c, x]
        else if 180 <= n and n < 240 then
            l = [0, x, c]
        else if 240 <= n and n < 300 then
            l = [x, 0, c]
        else
            l = [c, 0, x]
        end if
        r = (l[0] + m) * 255
        g = (l[1] + m) * 255
        b = (l[2] + m) * 255
        hex = "#"
        for i in [r, g, b]
            fv = floor(i / 16)
            sv = i % 16
            hex = hex + cs[fv] + cs[sv]
        end for
        return hex
    end function
	out = ""
	for i in str
		out = out+"<"+hexColor(__i_idx*(360/len(str)))+">"+i+"</color>"
	end for
	return out
end function

is_valid_ip_range = function(ip, allow_lan = true)
	is_valid_format = function(address, exclude_lan = false)
		if not address isa string then return false
		if address.len < 4 or address.len > 16 then return false
		sp = address.split("\.")
		if sp.len != 4 then return false
		lan = address[:7]
		if exclude_lan == true and (lan.is_match("172.16") or lan.is_match("10.0") or lan == "192.168") then return false
		for part in sp
			int = part.val
			if int == null or int <= 0 or int > 255 then return false
		end for
		return true
	end function
	if not is_valid_format(ip, not allow_lan) then return false

	ipToInt = function(ip)
		parts = ip.split("\.")
		return parts[0].to_int * 256 ^ 3 + parts[1].to_int * 256 ^ 2 + parts[2].to_int * 256 + parts[3].to_int
	end function

	blacklisted_ranges = {
	"0.0.0.0": "0.255.255.255",
	"10.0.0.0": "10.255.255.255",
	"100.64.0.0": "100.127.255.255",
	"127.0.0.0": "127.255.255.255",
	"169.254.0.0": "169.254.255.255",
	"172.16.0.0": "172.31.255.255",
	"192.0.0.0": "192.0.0.255",
	"192.0.2.0": "192.0.2.255",
	"192.88.99.0": "192.88.99.255",
	"198.18.0.0": "198.19.255.255",
	"198.51.100.0": "198.51.100.255",
	"203.0.113.0": "203.0.113.255",
	"224.0.0.0": "255.255.255.255",
	}

	ipNum = ipToInt(ip)
	for startIP in blacklisted_ranges.indexes
		endIP = blacklisted_ranges[startIP]
		startNum = ipToInt(startIP)
		endNum = ipToInt(endIP)
		if ipNum >= startNum and ipNum <= endNum then return false
	end for
	return true
end function

Binary = {}
Binary.New = function(bits=1)
    bin = new self
    self.bits = bits
    bin.bin = ""
    return bin
end function

Binary.register = function(val, bits)
    if val isa list then
        for x in range(0, len(val)-1)
            bin = int_to_bin(val[x])
            padding = "0" * (bits[x] - len(bin))
            self.bin = self.bin + padding + int_to_bin(val[x])
        end for
    else if val isa number then
        bin = int_to_bin(val)
        padding = "0"*(bits - len(bin))
        self.bin = self.bin + padding + int_to_bin(val)
    end if
end function

Binary.register_hex = function(hex, bits)
    if hex isa list then
        for x in range(0, len(hex)-1)
            bin = int_to_bin(hex_to_int(val[x]))
            padding = "0" * (bits[x] - len(bin))
            self.bin = self.bin + int_to_bin(hex_to_int(x))
        end for
    else if hex isa string then
        bin = int_to_bin(hex_to_int(hex))
        padding = "0"*(bits - len(bin))
        self.bin = self.bin + padding + int_to_bin(hex_to_int(hex))
    end if
end function

Binary.value = function()
    return bin_to_int(self.bin)
end function

Binary.hex_value = function()
    return int_to_hex(self.value)
end function

Binary.read = function(sections)
    bin = "0"*(self.bits - len(self.bin)) + self.bin
    if sum(sections) != len(bin) then
        return null
    end if
    result = []
    temp = bin

    for x in sections
        result.push(bin_to_int(temp[:x]))
        temp = temp[x:]
    end for

    return result
end function

get_epoch = function()
    _month = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]
    dt = current_date.split(" ")
    dates = dt[0].split("/"); times = dt[2].split(":")
    d = dates[0].to_int(); m = _month.indexOf(dates[1]) + 1; y = dates[2].to_int()
    y = y - (m <= 2)
    era = y; if y < 0 then era = y - 399; era = floor(era / 400)
    yoe = floor(y - era * 400)
    if m > 2 then t = m - 3 else t = m + 9
    doy = floor((153 * t + 2) / 5 + d - 1)
    doe = floor(yoe * 365 + yoe / 4 - yoe / 100 + doy)
    epoch_days = era * 146097 + doe - 719468 + 1
    
    result = (epoch_days * 24 + times[0].to_int()) * 3600 + times[1].to_int() * 60
    return result - 946684800
end function


is_version_greater = function(v1, v2)
    v2_split = v2.split("\.")

    for x in v1.split("\.")
        if to_int(x) > to_int(v2_split[__x_idx]) then
            return true
        else if to_int(x) < to_int(v2_split[__x_idx]) then
            return false
        end if
    end for
end function


select_prompt = function(msg, arr, silent=false)
    print("<#fa0>" + msg)
    if not silent then
        for i in range(1, arr.len)
            print("<#444>[<#f4c>" + i + "<#444>]<#6af> " + arr[i-1])
        end for
    end if

    result = user_input(": <#f4c>")
    while result != "" and not (result.to_int >= 1 and result.to_int <= arr.len)
        print("<#f47>Selection must be between <#fff>1<#f47> and <#fff>" + arr.len)
        result = user_input(": <#f4c>")
    end while

    if result == "" then 
        return null
    else
        return arr[result.to_int-1]
    end if 
end function


confirmation_prompt = function(msg)
    print("<#fa0>" + msg)
    while true
        inp = user_input("<#f4c>y / n <#446>: <#f4c>").lower()
        if ["y", "ye", "yes"].indexOf(inp) != null then return true
        if ["n", "no"].indexOf(inp) != null then return false
        print("<#f47>Please input (y)es or (n)o")
    end while
end function


// Deprecated, but here for backwards compat
enumerate = function(array)
    if not array isa list and not array isa string then return TypeError.New("enumerate","list", array)
    result = {}

    for x in array
        result[__x_idx] = x
    end for
    return result
end function